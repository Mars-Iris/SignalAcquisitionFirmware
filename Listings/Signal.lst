C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SIGNAL
OBJECT MODULE PLACED IN .\Objects\Signal.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE App\Signal.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\Signal.lst) TABS(2) OBJECT(.\Objects\Signal.obj)

line level    source

   1          #include  "./User/includes.h"
   2          #include  "./User/config.h"
   3          #include  <stdio.h>
   4          #include  <string.h>
   5          
   6          xdata SignalLineTypeDef SignalLine; 
   7          
   8          #ifdef  STC15W4K48S4  
   9          
  10          xdata PengganTypeDef        pilepole = {0};//桩杆
  11          xdata TiltSensorTypeDef     Tilt[4]={0};//倾角传感器
  12          xdata TiltAdjustTypeDef     mtc = {0};
  13          
  14          #endif
  15          
  16          
  17          //========================================================================
  18          // 函数: u8 zuozhuanxiangdeng(SignalLineTypeDef *pSignalLine)
  19          // 描述: 获取左转向灯信号,如开启双闪，返回FLASE
  20          // 参数：pSignalLine
  21          // 返回: 开启左转返回TURE，关闭左转返回FLASE
  22          // 版本: V1.0, 2022-10-17
  23          //========================================================================
  24          static u8 zuozhuanxiangdeng(SignalLineTypeDef *pSignalLine)  //左转向灯 D1
  25          {
  26   1        xdata u8 zz_pin = BSP_ReadInputDataBit(&pSignalLine->zz);//读取输入状态
  27   1        xdata u8 yz_pin = BSP_ReadInputDataBit(&pSignalLine->yz);//读取输入状态
  28   1        
  29   1        if(zz_pin == TURE && yz_pin == FALSE)
  30   1            return TURE;
  31   1        else 
  32   1            return FALSE;
  33   1      }
  34          //========================================================================
  35          // 函数: u8 youzhuanxiangdeng(SignalLineTypeDef *pSignalLine)
  36          // 描述: 获取右转向灯信号,如开启双闪，返回FLASE
  37          // 参数：pSignalLine
  38          // 返回: 开启右转返回TURE，关闭左转返回FLASE
  39          // 版本: V1.0, 2022-10-17
  40          //========================================================================
  41          static u8 youzhuanxiangdeng(SignalLineTypeDef *pSignalLine)  //右转向灯 D2
  42          {
  43   1        
  44   1        xdata u8 zz_pin = BSP_ReadInputDataBit(&pSignalLine->zz);//读取输入状态
  45   1        xdata u8 yz_pin = BSP_ReadInputDataBit(&pSignalLine->yz);//读取输入状态
  46   1        
  47   1        if(zz_pin == FALSE && yz_pin == TURE)
  48   1            return TURE;
  49   1        else 
  50   1            return FALSE;
  51   1        
  52   1      }
  53          //========================================================================
  54          // 函数: u8 xihuo(SignalLineTypeDef *pSignalLine)
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 2   

  55          // 描述: 获取车辆熄火状态,关联启动信号，着车之前必须出现启动信号。
  56          //       可使用开关量或则发动机转速评判熄火     
  57          // 参数：pSignalLine
  58          // 返回: 车辆着车返回TURE，车辆熄火返回FLASE
  59          // 版本: V1.0, 2022-10-17
  60          //========================================================================
  61          static u8 xihuo(SignalLineTypeDef *pSignalLine)  //熄火 D3
  62          {
  63   1        static u8 qidong_flag = FALSE;
  64   1        static u8 zhaoche_flag = FALSE;
  65   1        xdata u8 qd_pin   = BSP_ReadInputDataBit(&pSignalLine->qd);//读取输入状态
  66   1        xdata u8 xh_pin   = BSP_ReadInputDataBit(&pSignalLine->xh);//读取输入状态
  67   1        xdata u8 xh_type  = pSignalLine->xh.type;
  68   1        
  69   1        if(qd_pin == TURE)
  70   1            qidong_flag = TURE;//出现启动信号
  71   1      
  72   1          switch(xh_type) 
  73   1          {
  74   2            case SWITCHING://开关量评判模式(关联启动信号)
  75   2                            if((xh_pin == TURE) && (qidong_flag == TURE)) 
  76   2                            {
  77   3                              qidong_flag = FALSE;//清空启动信号标志为
  78   3                              zhaoche_flag = TURE;//车辆已经着车了
  79   3                              return TURE;        //
  80   3                            }
  81   2                            else if((xh_pin == TURE) && (zhaoche_flag == TURE))
  82   2                            { 
  83   3                              return TURE;
  84   3                            }
  85   2                            else 
  86   2                            {
  87   3                              zhaoche_flag = FALSE;
  88   3                              return FALSE;
  89   3                            }
  90   2            case SPEED://转速评判模式
  91   2                            return FALSE;
  92   2            case SWITCHING_AND_SPEED://开关量和转速评判
  93   2                            return FALSE;
  94   2            case SWITCHING_OR_SPEED://开关量或转速评判
  95   2                            return FALSE;
  96   2            default:
  97   2                            return FALSE; 
  98   2          }
  99   1      }
 100          //========================================================================
 101          // 函数: u8 shousha(SignalLineTypeDef *pSignalLine)
 102          // 描述: 获取手刹信号
 103          // 参数：pSignalLine，
 104          // 返回: 拉手刹返回TURE，松手刹返回FLASE
 105          // 版本: V1.0, 2022-10-17
 106          //========================================================================
 107          static u8 shousha(SignalLineTypeDef *pSignalLine)  //手刹D4
 108          {
 109   1        
 110   1        u8 ss_pin = BSP_ReadInputDataBit(&pSignalLine->ss);//读取输入状态
 111   1        
 112   1        return ss_pin;  
 113   1        
 114   1      }
 115          //========================================================================
 116          // 函数: u8 anquandai(SignalLineTypeDef *pSignalLine)
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 3   

 117          // 描述: 获取安全带信号
 118          // 参数：pSignalLine，
 119          // 返回: 系上安全带返回TURE，松开安全带返回FLASE
 120          // 版本: V1.0, 2022-10-17
 121          //========================================================================
 122          static u8 anquandai(SignalLineTypeDef *pSignalLine)  //安全带D5
 123          {
 124   1        
 125   1        u8 aqd_pin = BSP_ReadInputDataBit(&pSignalLine->aqd);//读取输入状态
 126   1        #ifdef DEBUG1
                      printf("aqd_pin = %b02d\r\n",aqd_pin);
                #endif  
 129   1        
 130   1        return aqd_pin; 
 131   1        
 132   1      }
 133          //========================================================================
 134          // 函数: u8 chenmen_zq(SignalLineTypeDef *pSignalLine)
 135          // 描述: 获取车门信号,左前、右前、左后、右后共四个门，
 136          // 参数：pSignalLine，
 137          // 返回: 打开车门返回FLASE，关闭车门返回0xF0,车门为高四位
 138          // 版本: V1.0, 2022-10-17
 139          //========================================================================
 140          static u8 chemen(SignalLineTypeDef *pSignalLine)      //车门D6
 141          {
 142   1        
 143   1        u8 cm_pin = BSP_ReadInputDataBit(&pSignalLine->cm);//读取输入状态
 144   1        
 145   1        if(cm_pin == TURE)
 146   1          return 0xF0;  //车门为高四位
 147   1        else 
 148   1          return FALSE;
 149   1        
 150   1      }
 151          //========================================================================
 152          // 函数: u8 daochedeng(SignalLineTypeDef *pSignalLine)
 153          // 描述: 获取倒车灯信号
 154          // 参数：pSignalLine，
 155          // 返回: 挂倒挡返回TURE，不在倒挡返回FLASE
 156          // 版本: V1.0, 2022-10-17
 157          //========================================================================
 158          static u8 daochedeng(SignalLineTypeDef *pSignalLine)  //倒车灯 D7
 159          {
 160   1        
 161   1        u8 dcd_pin = BSP_ReadInputDataBit(&pSignalLine->dcd);//读取输入状态
 162   1        
 163   1        return dcd_pin; 
 164   1        
 165   1      }
 166          //========================================================================
 167          // 函数: u8 laba(SignalLineTypeDef *pSignalLine)
 168          // 描述: 获取喇叭信号
 169          // 参数：pSignalLine，
 170          // 返回: 按喇叭返回TURE，松开喇叭返回FLASE
 171          // 版本: V1.0, 2022-10-17
 172          //========================================================================
 173          static u8 laba(SignalLineTypeDef *pSignalLine)  //喇叭  D8
 174          {
 175   1        
 176   1        u8 lb_pin = BSP_ReadInputDataBit(&pSignalLine->lb);//读取输入状态
 177   1        
 178   1        return lb_pin;  
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 4   

 179   1        
 180   1      }
 181          //========================================================================
 182          // 函数: u8 raoche1(SignalLineTypeDef *pSignalLine)
 183          // 描述: 获取绕车开关1信号
 184          // 参数：pSignalLine，
 185          // 返回: 按开关返回PRESS，松开开关返回NOPRESS
 186          // 版本: V1.0, 2022-10-17
 187          //========================================================================
 188          static u8 raoche1(SignalLineTypeDef *pSignalLine)  //绕车1   D9
 189          {
 190   1      
 191   1        u8 rc_pin1 = BSP_ReadMultipleDataBit(&pSignalLine->rc,RCPIN1);//读取输入状态
 192   1        
 193   1        (rc_pin1 == TURE)? (rc_pin1 = PRESS):(rc_pin1 = NOPRESS);//按照协议赋值
 194   1        
 195   1        return rc_pin1; 
 196   1        
 197   1      }
 198          //========================================================================
 199          // 函数: u8 raoche1(SignalLineTypeDef *pSignalLine)
 200          // 描述: 获取绕车开关2信号
 201          // 参数：pSignalLine，
 202          // 返回: 按开关返回PRESS，松开开关返回NOPRESS
 203          // 版本: V1.0, 2022-10-17
 204          //========================================================================
 205          static u8 raoche2(SignalLineTypeDef *pSignalLine)  //绕车2   D10
 206          {
 207   1        
 208   1        u8 rc_pin2 = BSP_ReadMultipleDataBit(&pSignalLine->rc,RCPIN2);//读取输入状态
 209   1        
 210   1        (rc_pin2 == TURE)? (rc_pin2 = PRESS):(rc_pin2 = NOPRESS);//按照协议赋值
 211   1        
 212   1        return rc_pin2; 
 213   1        
 214   1      }
 215          //========================================================================
 216          // 函数: u8 wudeng(SignalLineTypeDef *pSignalLine)
 217          // 描述: 获取雾灯开关2信号
 218          // 参数：pSignalLine，
 219          // 返回: 开雾灯返回TURE，关闭雾灯返回FLASE
 220          // 版本: V1.0, 2022-10-17
 221          //========================================================================
 222          static u8 wudeng(SignalLineTypeDef *pSignalLine)  //雾灯 D11
 223          {
 224   1        
 225   1        u8 wd_pin = BSP_ReadInputDataBit(&pSignalLine->wd);//读取输入状态
 226   1        
 227   1        return wd_pin;  
 228   1        
 229   1      }
 230          //========================================================================
 231          // 函数: u8 yuanguang(SignalLineTypeDef *pSignalLine)
 232          // 描述: 获取远光开关信号
 233          // 参数：pSignalLine，
 234          // 返回: 开远光灯返回TURE，关闭远光灯返回FLASE
 235          // 版本: V1.0, 2022-10-17
 236          //========================================================================
 237          static u8 yuanguang(SignalLineTypeDef *pSignalLine)  //远光 D12
 238          {
 239   1        
 240   1        u8 yg_pin = BSP_ReadInputDataBit(&pSignalLine->yg);//读取输入状态
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 5   

 241   1        
 242   1        return yg_pin;  
 243   1        
 244   1      }
 245          //========================================================================
 246          // 函数: u8 jinguang(SignalLineTypeDef *pSignalLine)
 247          // 描述: 获取近光开关信号
 248          // 参数：pSignalLine，
 249          // 返回: 开近光灯返回TURE，关闭近光灯返回FLASE
 250          // 版本: V1.0, 2022-10-17
 251          //========================================================================
 252          static u8 jinguang(SignalLineTypeDef *pSignalLine)  //近光 D13
 253          {
 254   1        
 255   1        u8 jg_pin = BSP_ReadInputDataBit(&pSignalLine->jg);//读取输入状态
 256   1        
 257   1        return jg_pin;  
 258   1        
 259   1      }
 260          //========================================================================
 261          // 函数: u8 xiaodeng(SignalLineTypeDef *pSignalLine)
 262          // 描述: 获取小灯开关信号
 263          // 参数：pSignalLine，
 264          // 返回: 开小灯返回TURE，关闭小灯返回FLASE
 265          // 版本: V1.0, 2022-10-17
 266          //========================================================================
 267          static u8 xiaodeng(SignalLineTypeDef *pSignalLine)  //小灯 D14
 268          {
 269   1        
 270   1        u8 xd_pin = BSP_ReadInputDataBit(&pSignalLine->xd);//读取输入状态
 271   1        
 272   1        return xd_pin;  
 273   1        
 274   1      }
 275          //========================================================================
 276          // 函数: u8 jiaosha(SignalLineTypeDef *pSignalLine)
 277          // 描述: 获取脚刹信号
 278          // 参数：pSignalLine，
 279          // 返回: 踩脚刹返回TURE，松开脚刹返回FLASE
 280          // 版本: V1.0, 2022-10-17
 281          //========================================================================
 282          static u8 jiaosha(SignalLineTypeDef *pSignalLine)  //脚刹 D15
 283          {
 284   1        
 285   1        u8 js_pin = BSP_ReadInputDataBit(&pSignalLine->js);//读取输入状态
 286   1        
 287   1        return js_pin;  
 288   1        
 289   1      }
 290          //========================================================================
 291          // 函数: u8 yushua(SignalLineTypeDef *pSignalLine)
 292          // 描述: 获取雨刷器信号
 293          // 参数：pSignalLine，
 294          // 返回: 开雨刷器返回TURE，关闭雨刷器返回FLASE
 295          // 版本: V1.0, 2022-10-17
 296          //========================================================================
 297          static u8 yushua(SignalLineTypeDef *pSignalLine)  //雨刷 D16
 298          {
 299   1        
 300   1        u8 ys_pin = BSP_ReadInputDataBit(&pSignalLine->ys);//读取输入状态
 301   1        
 302   1        return ys_pin;  
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 6   

 303   1        
 304   1      }
 305          //========================================================================
 306          // 函数: u8 zuohoushi(SignalLineTypeDef *pSignalLine)
 307          // 描述: 获取调节左后视镜信号
 308          // 参数：pSignalLine，
 309          // 返回: 调节左后视镜返回TURE，未调节返回FLASE
 310          // 版本: V1.0, 2022-10-17
 311          //========================================================================
 312          static u8 zuohoushi(SignalLineTypeDef *pSignalLine)  //左后视 D17
 313          {
 314   1        
 315   1        u8 zhs_pin = BSP_ReadInputDataBit(&pSignalLine->zhs);//读取输入状态
 316   1        
 317   1        return zhs_pin; 
 318   1        
 319   1      }
 320          //========================================================================
 321          // 函数: u8 qidong(SignalLineTypeDef *pSignalLine)
 322          // 描述: 获取启动开关信号
 323          // 参数：pSignalLine，
 324          // 返回: 启动点火时返回TURE，松开启动钥匙返回FLASE
 325          // 版本: V1.0, 2022-10-17
 326          //========================================================================
 327          static u8 qidong(SignalLineTypeDef *pSignalLine)  //启动开关 D18
 328          {
 329   1        
 330   1        u8 qd_pin = BSP_ReadInputDataBit(&pSignalLine->qd);//读取输入状态
 331   1        
 332   1        return qd_pin;  
 333   1        
 334   1      }
 335          //========================================================================
 336          // 函数: u8 neihoushi(SignalLineTypeDef *pSignalLine)
 337          // 描述: 获取调节内后视镜信号
 338          // 参数：pSignalLine，
 339          // 返回: 调节内后视镜返回TURE，未调节返回FLASE
 340          // 版本: V1.0, 2022-10-17
 341          //========================================================================
 342          static u8 neihoushi(SignalLineTypeDef *pSignalLine)  //内后视 D19
 343          {
 344   1        
 345   1        xdata u8 nhs_pin = BSP_ReadInputDataBit(&pSignalLine->nhs);//读取输入状态
 346   1        
 347   1        return nhs_pin; 
 348   1        
 349   1      }
 350          //========================================================================
 351          // 函数: u8 zuoyitiaojie(SignalLineTypeDef *pSignalLine)
 352          // 描述: 获取调节座椅信号
 353          // 参数：pSignalLine，
 354          // 返回: 调节座椅返回TURE，未调节返回FLASE
 355          // 版本: V1.0, 2022-10-17
 356          //========================================================================
 357          static u8 zuoyitiaojie(SignalLineTypeDef *pSignalLine)  //座椅调节开关 D20
 358          {
 359   1        
 360   1        u8 zytj_pin = BSP_ReadInputDataBit(&pSignalLine->zytj);//读取输入状态
 361   1        
 362   1        return zytj_pin;  
 363   1        
 364   1      }
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 7   

 365          //========================================================================
 366          // 函数: u8 dangwei(SignalLineTypeDef *pSignalLine)
 367          // 描述: 获取挡位信号，传感器类型有磁感和倾角两种类型。
 368          // 参数：pSignalLine，
 369          // 返回:  GEAR1    1档
 370          //        GEAR2    2档
 371          //        GEAR3    3档
 372          //        GEAR4    4档
 373          //        GEAR5    5档
 374          //        GEARR    R档
 375          // 版本: V1.0, 2022-10-17
 376          //========================================================================
 377          static u8 dangwei(SignalLineTypeDef *pSignalLine)  //挡位D21--D24
 378          {
 379   1        xdata u8 temp = 0;
 380   1        xdata u8 dw_pin1 = BSP_ReadMultipleDataBit(&pSignalLine->dw,DWPIN1);//读取输入状态D21
 381   1        xdata u8 dw_pin2 = BSP_ReadMultipleDataBit(&pSignalLine->dw,DWPIN2);//读取输入状态D22
 382   1        xdata u8 dw_pin3 = BSP_ReadMultipleDataBit(&pSignalLine->dw,DWPIN3);//读取输入状态D23
 383   1        xdata u8 dw_pin4 = BSP_ReadMultipleDataBit(&pSignalLine->dw,DWPIN4);//读取输入状态D24
 384   1        xdata u8 dw_type = pSignalLine->dw.type;//获取传感器类型
 385   1        
 386   1        switch(dw_type)
 387   1        {
 388   2          case  MAGNETIC://磁传感器
 389   2                          temp = (dw_pin1<<0 | dw_pin2<<1 | dw_pin3<<2 | dw_pin4<<3);
 390   2                          if(temp == 0x01)
 391   2                            return  GEAR1;
 392   2                          else if(temp == 0x02)
 393   2                            return  GEAR2;
 394   2                          else if(temp == 0x04)
 395   2                            return  GEAR3;
 396   2                          else if(temp == 0x08)
 397   2                            return  GEAR4;
 398   2                          else if(temp == 0x05)
 399   2                            return  GEAR5;
 400   2                          else if(temp == 0x0F)
 401   2                            return  GEARR;
 402   2                          else 
 403   2                            return  FALSE;
 404   2          case  ANGLE://磁传感器
 405   2                          temp = (dw_pin1<<0 | dw_pin2<<1 | dw_pin3<<2);
 406   2                          if(temp == 0x06)
 407   2                            return  GEAR1;
 408   2                          else if(temp ==  0x05)
 409   2                            return  GEAR2;
 410   2                          else if(temp ==  0x04)
 411   2                            return  GEAR3;
 412   2                          else if(temp ==  0x03)
 413   2                            return  GEAR4;
 414   2                          else if(temp ==  0x02)
 415   2                            return  GEAR5;
 416   2                          else if(temp ==  0x01)
 417   2                            return  GEARR;
 418   2                          else 
 419   2                            return  FALSE;
 420   2          default:
 421   2            
 422   2                return  FALSE;        
 423   2        }
 424   1      
 425   1        
 426   1      }
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 8   

 427          //========================================================================
 428          // 函数: u8 zuoyiyali(SignalLineTypeDef *pSignalLine)
 429          // 描述: 获取座椅（压力）信号
 430          // 参数：pSignalLine，
 431          // 返回: 座椅有压力返回TURE，没有压力返回FLASE
 432          // 版本: V1.0, 2022-10-17
 433          //========================================================================
 434          static u8 zuoyiyali(SignalLineTypeDef *pSignalLine)  ///座椅（压力） D25
 435          {
 436   1        
 437   1        xdata u8 zyyl_pin = BSP_ReadInputDataBit(&pSignalLine->zyyl);//读取输入状态
 438   1        
 439   1        return zyyl_pin;  
 440   1        
 441   1      }
 442          //========================================================================
 443          // 函数: u8 lihe(SignalLineTypeDef *pSignalLine)
 444          // 描述: 获取离合器信号
 445          // 参数：pSignalLine，
 446          // 返回: 踩下离合器返回TURE，抬起离合器返回FLASE
 447          // 版本: V1.0, 2022-10-17
 448          //========================================================================
 449          static u8 lihe(SignalLineTypeDef *pSignalLine)   //离合 D26
 450          {
 451   1        
 452   1        u8 lh_pin = BSP_ReadInputDataBit(&pSignalLine->lh);//读取输入状态
 453   1        
 454   1        return lh_pin;  
 455   1        
 456   1      }
 457          //========================================================================
 458          // 函数: u8 yaoshimen(SignalLineTypeDef *pSignalLine)
 459          // 描述: 获取钥匙门信号
 460          // 参数：pSignalLine，
 461          // 返回: 打开钥匙门开关返回TURE，关闭钥匙门开关返回FLASE
 462          // 版本: V1.0, 2022-10-17
 463          //========================================================================
 464          static u8 yaoshimen(SignalLineTypeDef *pSignalLine)   //钥匙门开关 D28
 465          {
 466   1        
 467   1        u8 ysm_pin = BSP_ReadInputDataBit(&pSignalLine->ysm);//读取输入状态
 468   1        
 469   1        return ysm_pin; 
 470   1        
 471   1      }
 472          //========================================================================
 473          // 函数: u8 fushache(SignalLineTypeDef *pSignalLine)
 474          // 描述: 获取副刹信号
 475          // 参数：pSignalLine，
 476          // 返回: 踩下副刹车返回TURE，抬起副刹车返回FLASE
 477          // 版本: V1.0, 2022-10-17
 478          //========================================================================
 479          static u8 fushache(SignalLineTypeDef *pSignalLine)   //副刹车 D29
 480          {
 481   1        
 482   1        u8 fsc_pin = BSP_ReadInputDataBit(&pSignalLine->fsc);//读取输入状态
 483   1        
 484   1        return fsc_pin; 
 485   1        
 486   1      }
 487          //========================================================================
 488          // 函数: u8 chuangdong(SignalLineTypeDef *pSignalLine)
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 9   

 489          // 描述: 获取起步时闯动信号
 490          // 参数：pSignalLine，
 491          // 返回: 出线闯动返回TURE，平稳返回FLASE
 492          // 版本: V1.0, 2022-10-17
 493          //========================================================================
 494          static u8 chuangdong(SignalLineTypeDef *pSignalLine)   //闯动传感器 D30
 495          {
 496   1        
 497   1        u8 cd_pin = BSP_ReadInputDataBit(&pSignalLine->cd);//读取输入状态
 498   1        
 499   1        return cd_pin;  
 500   1        
 501   1      }
 502          //========================================================================
 503          // 函数: u8 raoche3(SignalLineTypeDef *pSignalLine)
 504          // 描述: 获取绕车3信号
 505          // 参数：pSignalLine，
 506          // 返回: 按下返回TURE，未按下FLASE
 507          // 版本: V1.0, 2022-10-17
 508          //========================================================================
 509          static u8 raoche3(SignalLineTypeDef *pSignalLine)   //绕车3  D31
 510          {
 511   1        
 512   1        u8 rc_pin3 = BSP_ReadMultipleDataBit(&pSignalLine->rc,RCPIN3);//读取输入状态
 513   1        
 514   1        (rc_pin3 == TURE)? (rc_pin3 = PRESS):(rc_pin3 = NOPRESS);//按照协议赋值
 515   1        
 516   1        return rc_pin3; 
 517   1        
 518   1      }
 519          //========================================================================
 520          // 函数: u8 shijing(SignalLineTypeDef *pSignalLine)
 521          // 描述: 获取双闪信号
 522          // 参数：pSignalLine，
 523          // 返回: 打开双闪返回TURE，关闭双闪返回FLASE
 524          // 版本: V1.0, 2022-10-17
 525          //========================================================================
 526          static u8 shijing(SignalLineTypeDef *pSignalLine)   //示警开关
 527          {
 528   1        
 529   1        u8 zz_pin = BSP_ReadInputDataBit(&pSignalLine->zz);//读取输入状态
 530   1        u8 yz_pin = BSP_ReadInputDataBit(&pSignalLine->yz);//读取输入状态
 531   1        
 532   1        if(zz_pin == TURE && yz_pin == TURE)
 533   1            return TURE;
 534   1        else 
 535   1            return FALSE;
 536   1        
 537   1      }
 538          //========================================================================
 539          // 函数: u8 kongdang(SignalLineTypeDef *pSignalLine)
 540          // 描述: 获取空挡信号
 541          // 参数：pSignalLine，
 542          // 返回: 空挡返回TURE，非空挡返回FLASE
 543          // 版本: V1.0, 2022-10-17
 544          //========================================================================
 545          static u8 kongdang(SignalLineTypeDef *pSignalLine)   //空挡
 546          {
 547   1        
 548   1        if(dangwei(pSignalLine) != FALSE)
 549   1            return TURE;
 550   1        else 
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 10  

 551   1            return FALSE;
 552   1        
 553   1      }
 554          //========================================================================
 555          // 函数: u8 guanchayibiao(SignalLineTypeDef *pSignalLine)
 556          // 描述: 获取观察仪表盘信号
 557          // 参数：pSignalLine，
 558          // 返回: 观察返回TURE，没有观察返回FLASE
 559          // 版本: V1.0, 2022-10-17
 560          //========================================================================
 561          static u8 guanchayibiao(SignalLineTypeDef *pSignalLine)   //观察仪表盘
 562          {
 563   1        
 564   1        u8 gcybp_pin = BSP_ReadInputDataBit(&pSignalLine->gcybp);//读取输入状态
 565   1        
 566   1        return gcybp_pin; 
 567   1        
 568   1      }
 569          //========================================================================
 570          // 函数: u8 DBQ_LeftFront(SignalLineTypeDef *pSignalLine)
 571          // 描述: 获取单边桥传感器左前轮信号
 572          // 参数：pSignalLine，
 573          // 返回: 在桥上返回TURE，不桥上返回FLASE
 574          // 版本: V1.0, 2022-10-17
 575          //========================================================================
 576          static u8 DBQ_LeftFront(SignalLineTypeDef *pSignalLine)    //单边桥左前轮状态
 577          {
 578   1        u8 dbq_pin1 = BSP_ReadMultipleDataBit(&pSignalLine->dbq,LEFT_FRONT_WHEEL);//读取输入状态
 579   1        
 580   1        return dbq_pin1;
 581   1      
 582   1      }
 583          //========================================================================
 584          // 函数: u8 DBQ_LeftRear(SignalLineTypeDef *pSignalLine)
 585          // 描述: 获取单边桥传感器左后轮信号
 586          // 参数：pSignalLine，
 587          // 返回: 在桥上返回TURE，不桥上返回FLASE
 588          // 版本: V1.0, 2022-10-17
 589          //========================================================================
 590          static u8 DBQ_LeftRear(SignalLineTypeDef *pSignalLine)    //单边桥左后轮状态
 591          {
 592   1        u8 dbq_pin2 = BSP_ReadMultipleDataBit(&pSignalLine->dbq,LEFT_REAR_WHEEL);//读取输入状态
 593   1        
 594   1        return dbq_pin2;
 595   1      
 596   1      }
 597          //========================================================================
 598          // 函数: u8 DBQ_LeftRear(SignalLineTypeDef *pSignalLine)
 599          // 描述: 获取单边桥传感器右前轮信号
 600          // 参数：pSignalLine，
 601          // 返回: 在桥上返回TURE，不桥上返回FLASE
 602          // 版本: V1.0, 2022-10-17
 603          //========================================================================
 604          static u8 DBQ_RightFront(SignalLineTypeDef *pSignalLine)    //单边桥右前轮状态
 605          {
 606   1        u8 dbq_pin3 = BSP_ReadMultipleDataBit(&pSignalLine->dbq,RIGHT_FRONT_WHEEL);//读取输入状态
 607   1        
 608   1        return dbq_pin3;
 609   1      
 610   1      }
 611          //========================================================================
 612          // 函数: u8 DBQ_RightRear(SignalLineTypeDef *pSignalLine)
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 11  

 613          // 描述: 获取单边桥传感器右后轮信号
 614          // 参数：pSignalLine，
 615          // 返回: 在桥上返回TURE，不桥上返回FLASE
 616          // 版本: V1.0, 2022-10-17
 617          //========================================================================
 618          static u8 DBQ_RightRear(SignalLineTypeDef *pSignalLine)    //单边桥右后轮状态
 619          {
 620   1        u8 dbq_pin4 = BSP_ReadMultipleDataBit(&pSignalLine->dbq,RIGHT_REAR_WHEEL);//读取输入状态
 621   1        
 622   1        return dbq_pin4;
 623   1      
 624   1      }
 625          //========================================================================
 626          // 函数: u8 DBQ_LeftMiddle(SignalLineTypeDef *pSignalLine)
 627          // 描述: 获取单边桥传感器左挂车轮信号
 628          // 参数：pSignalLine，
 629          // 返回: 在桥上返回TURE，不桥上返回FLASE
 630          // 版本: V1.0, 2022-10-17
 631          //========================================================================
 632          static u8 DBQ_LeftMiddle(SignalLineTypeDef *pSignalLine)    //单边桥左挂车轮状态
 633          {
 634   1        u8 dbq_pin5 = BSP_ReadMultipleDataBit(&pSignalLine->dbq,LEFT_MIDDLE_WHEEL);//读取输入状态
 635   1        
 636   1        return dbq_pin5;
 637   1      
 638   1      }
 639          //========================================================================
 640          // 函数: u8 DBQ_RightMiddle(SignalLineTypeDef *pSignalLine)
 641          // 描述: 获取单边桥传感器右挂车轮信号
 642          // 参数：pSignalLine，
 643          // 返回: 在桥上返回TURE，不桥上返回FLASE
 644          // 版本: V1.0, 2022-10-17
 645          //========================================================================
 646          static u8 DBQ_RightMiddle(SignalLineTypeDef *pSignalLine)    //单边桥右挂车轮状态
 647          {
 648   1        u8 dbq_pin6 = BSP_ReadMultipleDataBit(&pSignalLine->dbq,RIGHT_MIDDLE_WHEEL);//读取输入状态
 649   1        
 650   1        return dbq_pin6;
 651   1      
 652   1      }
 653          //========================================================================
 654          // 函数: u8 zhuansucount(SignalLineTypeDef *pSignalLine)
 655          // 描述: 获取转速的脉冲计数值
 656          // 参数：pSignalLine，
 657          // 返回: 在桥上返回TURE，不桥上返回FLASE
 658          // 版本: V1.0, 2022-10-17
 659          //========================================================================
 660          static u16 zhuansucount(SignalLineTypeDef *pSignalLine)    //脉冲计数
 661          {
 662   1        static u8 times = 0;//采样等待次数（时间）
 663   1        static u16 count = 0;//获取转速初值
 664   1        
 665   1        if(times == pSignalLine->zs.sampling_time)//到达采样时间
 666   1        {
 667   2          times = 0;
 668   2          count = TH0;
 669   2          count = count<<8; 
 670   2          count = count + TL0;    
 671   2          TH0 = 0;//清零
 672   2          TL0 = 0;//清零  
 673   2          if ((count == 0) && (pSignalLine->zs.init_value == 1))
 674   2          {
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 12  

 675   3            count = 800;  //贵州特殊要求
 676   3          }
 677   2        }
 678   1        else
 679   1        {
 680   2          times++;
 681   2        }
 682   1        return count;
 683   1      
 684   1      }
 685          #ifdef  STC15W4K48S4
 686          
 687          //========================================================================
 688          // 函数: u8 toukui(SignalLineTypeDef *pSignalLine)
 689          // 描述: 获取摩托车头盔状态
 690          // 参数：pSignalLine，
 691          // 返回: 戴上返回TURE，取下返回FLASE
 692          // 版本: V1.0, 2022-10-17
 693          //========================================================================
 694          static u8 toukui(SignalLineTypeDef *pSignalLine)    //摩托车头盔
 695          {
 696   1        u8 tk_pin = BSP_ReadInputDataBit(&pSignalLine->tk);//读取输入状态
 697   1        
 698   1        return tk_pin;
 699   1      
 700   1      }
 701          //========================================================================
 702          // 函数: u8 zuobashou(SignalLineTypeDef *pSignalLine)
 703          // 描述: 获取摩托车左把手状态
 704          // 参数：pSignalLine，
 705          // 返回: 握住返回TURE，离开返回FLASE
 706          // 版本: V1.0, 2022-10-17
 707          //========================================================================
 708          static u8 zuobashou(SignalLineTypeDef *pSignalLine)    //摩托车左把手
 709          {
 710   1        u8 zbs_pin = BSP_ReadInputDataBit(&pSignalLine->zbs);//读取输入状态
 711   1        
 712   1        return zbs_pin;
 713   1      
 714   1      }
 715          //========================================================================
 716          // 函数: u8 youbashou(SignalLineTypeDef *pSignalLine)
 717          // 描述: 获取摩托车右把手状态
 718          // 参数：pSignalLine，
 719          // 返回: 握住返回TURE，离开返回FLASE
 720          // 版本: V1.0, 2022-10-17
 721          //========================================================================
 722          static u8 youbashou(SignalLineTypeDef *pSignalLine)    //摩托车右把手
 723          {
 724   1        u8 ybs_pin = BSP_ReadInputDataBit(&pSignalLine->ybs);//读取输入状态
 725   1        
 726   1        return ybs_pin;
 727   1      
 728   1      }
 729          //========================================================================
 730          // 函数: u8 zuojiaotaban(SignalLineTypeDef *pSignalLine)
 731          // 描述: 获取摩托车右把手状态
 732          // 参数：pSignalLine，
 733          // 返回: 踩住返回TURE，离开返回FLASE
 734          // 版本: V1.0, 2022-10-17
 735          //========================================================================
 736          static u8 zuojiaotaban(SignalLineTypeDef *pSignalLine)    //摩托车左脚踏板
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 13  

 737          {
 738   1        u8 zjtb_pin = BSP_ReadInputDataBit(&pSignalLine->zjtb);//读取输入状态
 739   1        
 740   1        return zjtb_pin;
 741   1      
 742   1      }
 743          //========================================================================
 744          // 函数: u8 youtaban(SignalLineTypeDef *pSignalLine)
 745          // 描述: 获取摩托车右把手状态
 746          // 参数：pSignalLine，
 747          // 返回: 踩住返回TURE，离开返回FLASE
 748          // 版本: V1.0, 2022-10-17
 749          //========================================================================
 750          static u8 youjiaotaban(SignalLineTypeDef *pSignalLine)    //摩托车右脚踏板
 751          {
 752   1        u8 yjtb_pin = BSP_ReadInputDataBit(&pSignalLine->yjtb);//读取输入状态
 753   1        
 754   1        return yjtb_pin;
 755   1      
 756   1      }
 757          
 758          //========================================================================
 759          // 函数: u8 GetHSShockSensor_value(u8 bump_usart,SignalLineTypeDef *pole)
 760          // 描述: 采集高森碰杆传感器的数据
 761          // 参数：bump_usart传感器与主板之间的串口号，SignalLineTypeDef数据结构
 762          // 返回: 
 763          // 版本: V1.0, 2022-10-17
 764          //========================================================================
 765          static void GetHSShockSensor_value(u8 bump_usart,SignalLineTypeDef *pole)    //得到高森碰杆传感器的值
 766          {
 767   1        xdata u8 group_i = 0;//
 768   1        xdata u8 temp = 0;//
 769   1        xdata u16 value = 0;//
 770   1        xdata u8 valuebit = 0;//
 771   1        xdata u8 i = 0;
 772   1        static u8 gor_i = 0;
 773   1        static u8 pos_i = 0;
 774   1        
 775   1        if(bump_usart == DISABLE) //硬件串口未初始化
 776   1        {
 777   2          return;
 778   2        }
 779   1        
 780   1        pilepole.name   = 0;  //上传碰杆状态  清零
 781   1        pilepole.number = 0;  //上传碰杆状态  清零    
 782   1        pilepole.value  = 0;  //上传碰杆位置  清零
 783   1        
 784   1        if (Serial_HighSensorShock_Analy(bump_usart,pole) == TURE)//读取到串口数据
 785   1        {
 786   2        
 787   2              for (group_i = 0; group_i < sizeof(pole->bump)/sizeof(pole->bump[0]);group_i++)
 788   2              {
 789   3                
 790   3                if(pole->bump[group_i].name == 0) 
 791   3                {
 792   4                  break;//flash里面未配置碰杆接收项目
 793   4                }
 794   3                value  =   pole->bump[group_i].value;//取碰杆状态
 795   3                
 796   3                //printf("value = %h04X\r\n",value);
 797   3                
 798   3                for (i = 0 ; i< pole->bump[group_i].count;i++)
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 14  

 799   3                {   
 800   4                  valuebit  = (u16)(value >> i) & (0x0001);//取出碰杆位
 801   4                  
 802   4                  temp = BSP_ReadBumpDataBit(&pole->pgjs,group_i,valuebit,i);//消抖处理
 803   4                  
 804   4                  if( temp == 0 )
 805   4                  {
 806   5                    pole->bump[group_i].value &= ~(1<< i);//更新消抖处理结果
 807   5                  }
 808   4                  else 
 809   4                    pole->bump[group_i].value |= (1<< i);//更新消抖处理结果
 810   4                }
 811   3                //printf("pole->bump[group_i].value = %h04X\r\n",pole->bump[group_i].value);
 812   3                
 813   3                
 814   3              }
 815   2              //由于需要轮询碰杆状态，所以需要第二次遍历，并且需要记录遍历的位置
 816   2              for ( ;gor_i < sizeof(pole->bump)/sizeof(pole->bump[0]);gor_i++)
 817   2              {
 818   3                
 819   3                if(pole->bump[gor_i].name == 0) 
 820   3                {
 821   4                  gor_i = 0;
 822   4                  
 823   4                  break;//flash里面未配置碰杆接收项目
 824   4                }
 825   3                
 826   3                value  =  pole->bump[gor_i].value;//取碰杆状态
 827   3                
 828   3                //printf("penggan.value = %h04X\r\n",value);
 829   3                
 830   3                for (;pos_i< pole->bump[gor_i].count;pos_i++)
 831   3                {
 832   4                  
 833   4                  valuebit = (u8)(value >> pos_i) & (0x0001);//取出碰杆位
 834   4                  
 835   4                  if(valuebit == 1)//出现碰杆信号
 836   4                  {
 837   5                      pilepole.name   = pole->bump[gor_i].name;     //上传碰杆状态  
 838   5                      pilepole.number = pole->bump[gor_i].number;   //上传碰杆状态      
 839   5                      pilepole.value  = pos_i+1;  //上传碰杆位置
 840   5                      pos_i++;//本次循环结束
 841   5                     
 842   5                     //printf("penggan.value = %h04X\r\n",value);
 843   5                     //printf("pilepole.name = %b02d\r\n",pilepole.name);
 844   5                     //printf("pilepole.number = %b02d\r\n",pilepole.number);
 845   5                     //printf("pilepole.value = %h04d\r\n",pilepole.value);
 846   5                     //printf("\r\n");
 847   5                    
 848   5                      return;
 849   5                  }
 850   4                }
 851   3                pos_i = 0;
 852   3                
 853   3              }
 854   2              gor_i = 0;
 855   2        } 
 856   1      }
 857          
 858          //========================================================================
 859          // 函数: u8 Get24GShockSensor_value(u8 Tilt_usart)
 860          // 描述: 获取2.4碰杆传感器的值
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 15  

 861          // 参数：u8 bump_usart，2.4G模块与主板之间连接的串口号
 862          // 返回: 
 863          // 版本: V1.0, 2022-10-17
 864          //========================================================================
 865          static void Get24GShockSensor_value(u8 bump_usart)    //得到2.4G碰杆碰杆传感器的值
 866          {
 867   1      
 868   1        if(bump_usart != DISABLE)
 869   1        {
 870   2              //memset(&Tilt,0,sizeof(Tilt));//清空数据
 871   2              pilepole.name   = 0;  //上传碰杆状态  清零
 872   2              pilepole.number = 0;  //上传碰杆状态  清零    
 873   2              pilepole.value  = 0;  //上传碰杆位置  清零
 874   2              Serial_Sensor24GShock_Analy(bump_usart,&pilepole);
 875   2        }
 876   1      }
 877          
 878          //========================================================================
 879          // 函数: u8 GetTiltSensor_value(u8 Tilt_usart,TiltSensorTypeDef *pTilt)
 880          // 描述: 获取倾角传感器的值
 881          // 参数：u8 Tilt_usart，传感器与主板之间连接的串口号， pTilt指向数据保存的指针
 882          // 返回: 
 883          // 版本: V1.0, 2022-10-17
 884          //========================================================================
 885          static void GetTiltSensor_value(u8 Tilt_usart,TiltSensorTypeDef *pTilt)    //倾角传感器的值
 886          {
 887   1      
 888   1        #if TILT_ALL_USART //全部读取
                    Serial_TiltSensor_Analy(Tilt_usart,pTilt);
                
              //     printf("------------------------------------------\r\n");
              //     printf("Tilt[PLACE_Q_AXLE].Roll = %h04d\r\n",    Tilt[PLACE_Q_AXLE].Roll);
              //     printf("Tilt[PLACE_Q_AXLE].Pitch = %h04d\r\n",   Tilt[PLACE_Q_AXLE].Pitch);
              //     printf("Tilt[PLACE_Q_AXLE].Yaw = %h04d\r\n",     Tilt[PLACE_Q_AXLE].Yaw);
              //     printf("------------------------------------------\r\n");
                #else
 897   1        if(Tilt_usart != DISABLE)//单个读取
 898   1        {
 899   2           //memset(pTilt,0,sizeof(Tilt[0]));//清零
 900   2           if (Serial_TiltSensor_Analy(Tilt_usart,pTilt) == TURE)//单个读取
 901   2           {
 902   3             if(Tilt_usart == TILT_MTC_USART) //如果是二轮摩托车
 903   3             {
 904   4         
 905   4                (char)pTilt->RollL -= mtc.Adjust_XL;    //得到X轴差值低字节 
 906   4                (char)pTilt->RollH -= mtc.Adjust_XH;    //得到X轴差值高字节 
 907   4                (char)pTilt->PitchL -= mtc.Adjust_YL;  //得到Y轴差值低字节    
 908   4                (char)pTilt->PitchH -= mtc.Adjust_YH;  //得到Y轴差值高字节  
 909   4               
 910   4      //          printf("pTilt->RollL = %b02d\r\n",  pTilt->RollL);
 911   4      //          printf("pTilt->RollH = %b02d\r\n",  pTilt->RollH);
 912   4      //          printf("pTilt->PitchL = %b02d\r\n", pTilt->PitchL);
 913   4      //          printf("pTilt->PitchH = %b02d\r\n", pTilt->PitchH); 
 914   4      //          printf("\r\n");        
 915   4             }
 916   3           }     
 917   2        }
 918   1        #endif
 919   1      }
 920          
 921          //========================================================================
 922          // 函数: void GetTilt_Adjust_vaule(u8 Tilt_usart,u8 *TiltSensorTypeDef pTilt) //获取摩托车倾角传感器校准值
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 16  

 923          // 描述: 获取倾角传感器的基准值
 924          // 参数：u8 Tilt_usart，传感器与主板之间连接的串口号，pTilt指向数据保存的指针
 925          // 返回: 
 926          // 版本: V1.0, 2022-10-17
 927          //========================================================================
 928          static void  GetTilt_Adjust_vaule(u8 Tilt_usart,TiltSensorTypeDef *pTilt) //获取摩托车倾角传感器校准值
 929          {
 930   1        if(Tilt_usart != DISABLE)
 931   1        {
 932   2          GetTiltSensor_value(Tilt_usart,pTilt);//获取基准值
 933   2          mtc.Adjust_XL = pTilt->RollL;         //X轴角度低字节 
 934   2          mtc.Adjust_XH = pTilt->RollH;         //X轴角度高字节
 935   2          mtc.Adjust_YL = pTilt->PitchL;          //Y轴角度低字节
 936   2          mtc.Adjust_YH = pTilt->PitchH;          //Y轴角度高字节 
 937   2          
 938   2      //    printf("mtc.Adjust_XL = %b02d\r\n", mtc.Adjust_XL);
 939   2      //    printf("mtc.Adjust_XH = %b02d\r\n", mtc.Adjust_XH);
 940   2      //    printf("mtc.Adjust_YL = %b02d\r\n",mtc.Adjust_YL);
 941   2      //    printf("mtc.Adjust_YH = %b02d\r\n",mtc.Adjust_YH);  
 942   2        }
 943   1      }
 944          #endif
 945          //========================================================================
 946          // 函数: void Cmd_Start_Callback(void)
 947          // 描述: 主板收到55 aa 00 00 11 11 后会调用此函数
 948          // 版本: V1.0, 2022-10-17
 949          //========================================================================
 950          void Cmd_Start_Callback(void)
 951          {
 952   1        USART_ClearMsgQueueRxBuffer(UPLOAD_USART);
 953   1        
 954   1        BSP_ClearUsartRxBuffer(UPLOAD_USART);//
 955   1        
 956   1        SignalLine_Init();//获取最新的配置文件
 957   1        
 958   1      #ifdef  STC15W4K48S4
 959   1        USART_ClearMsgQueueRxBuffer(TILT_MTC_USART);//清理串口缓存
 960   1        
 961   1        BSP_ClearUsartRxBuffer(TILT_MTC_USART);//
 962   1        
 963   1        delay_ms(200);//延时300毫秒读取基准值
 964   1        
 965   1        GetTilt_Adjust_vaule(TILT_MTC_USART,&Tilt[PLACE_MTC_AXLE]);//获取传二轮摩托车传感器的基准值
 966   1        
 967   1      #endif
 968   1      }
 969          
 970          //========================================================================
 971          // 函数: void SignalLine_Init(void)
 972          // 描述: 初始化信号的配置，输入端口未配置，按默认端口接线
 973          // 参数：无
 974          // 版本: V1.0, 2022-10-17
 975          //========================================================================
 976          void SignalLine_Init(void)
 977          {
 978   1          xdata SignalLineTypeDef *pSignalLine = &SignalLine;
 979   1        
 980   1          BSP_GetFlashConfig(pSignalLine);  //获取配置参数
 981   1        
 982   1          if(pSignalLine->zz.pin == 0)      pSignalLine->zz.pin   = D1;   //左转,默认端口为D1
 983   1          if(pSignalLine->yz.pin == 0)      pSignalLine->yz.pin   = D2;   //右转,默认端口为D2
 984   1          if(pSignalLine->xh.pin == 0)      pSignalLine->xh.pin   = D3;   //发电机,默认端口为D3
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 17  

 985   1          if(pSignalLine->ss.pin == 0)      pSignalLine->ss.pin   = D4;   //手刹,默认端口为D4
 986   1          if(pSignalLine->aqd.pin == 0)     pSignalLine->aqd.pin  = D5;   //安全带,默认端口为D5 
 987   1          if(pSignalLine->cm.pin == 0)      pSignalLine->cm.pin   = D6;   //车门,默认端口为D6
 988   1          if(pSignalLine->dcd.pin == 0)     pSignalLine->dcd.pin  = D7;   //倒车灯,默认端口为D7
 989   1          if(pSignalLine->lb.pin == 0)      pSignalLine->lb.pin   = D8;   //喇叭,默认端口为D8
 990   1        
 991   1          if(pSignalLine->rc.pin1 == 0)     pSignalLine->rc.pin1  = D9;   //绕车1,默认端口为D9
 992   1          if(pSignalLine->rc.pin2 == 0)     pSignalLine->rc.pin2  = D10;  //绕车2,默认端口为D10
 993   1          if(pSignalLine->wd.pin == 0)      pSignalLine->wd.pin   = D11;  //雾灯,默认端口为D11
 994   1          if(pSignalLine->yg.pin == 0)      pSignalLine->yg.pin   = D12;  //远光,默认端口为D12
 995   1          if(pSignalLine->jg.pin == 0)      pSignalLine->jg.pin   = D13;  //近光,默认端口为D13  
 996   1          if(pSignalLine->xd.pin == 0)      pSignalLine->xd.pin   = D14;  //小灯,默认端口为D14
 997   1          if(pSignalLine->js.pin == 0)      pSignalLine->js.pin   = D15;  //脚刹,默认端口为D15
 998   1          if(pSignalLine->ys.pin == 0)      pSignalLine->ys.pin   = D16;  //雨刷,默认端口为D16
 999   1        
1000   1          if(pSignalLine->zhs.pin == 0)     pSignalLine->zhs.pin  = D17;  //左后视镜,默认端口为D17
1001   1          if(pSignalLine->qd.pin == 0)      pSignalLine->qd.pin   = D18;  //启动,默认端口为D18
1002   1          if(pSignalLine->nhs.pin == 0)     pSignalLine->nhs.pin  = D19;  //内后视镜,默认端口为D19
1003   1          if(pSignalLine->zyyl.pin == 0)    pSignalLine->zyyl.pin = D20;  //远座椅(压力,默认端口为D20
1004   1          if(pSignalLine->dw.pin1 == 0)     pSignalLine->dw.pin1  = D21;  //挡位1,默认端口为D21 
1005   1          if(pSignalLine->dw.pin2 == 0)     pSignalLine->dw.pin2  = D22;  //挡位2,默认端口为D22
1006   1          if(pSignalLine->dw.pin3 == 0)     pSignalLine->dw.pin3  = D23;  //挡位3,默认端口为D23
1007   1          if(pSignalLine->dw.pin4 == 0)     pSignalLine->dw.pin4  = D24;  //挡位4,默认端口为D24
1008   1          
1009   1          if(pSignalLine->zytj.pin == 0)    pSignalLine->zytj.pin = D25;  //调座椅,默认端口为D25
1010   1          if(pSignalLine->lh.pin == 0)      pSignalLine->lh.pin   = D26;  //离合,默认端口为D26
1011   1          if(pSignalLine->zs.pin == 0)      pSignalLine->zs.pin   = D27;  //转速,默认端口为D27
1012   1          if(pSignalLine->ysm.pin == 0)     pSignalLine->ysm.pin  = D28;  //钥匙开关,默认端口为D28
1013   1          if(pSignalLine->fsc.pin == 0)     pSignalLine->fsc.pin  = D29;  //副刹车,默认端口为D29  
1014   1          if(pSignalLine->cd.pin == 0)      pSignalLine->cd.pin   = D30;  //闯动传感器,默认端口为D30
1015   1          //if(pSignalLine->dw3.pin == 0)   pSignalLine->dw3.pin  = D31;  //备用,默认端口为D31
1016   1          if(pSignalLine->rc.pin3 == 0)     pSignalLine->rc.pin3  = D32;  //绕车3,默认端口为D32
1017   1          
1018   1        #ifdef  STC15W4K48S4  
1019   1          if(pSignalLine->tk.pin == 0)      pSignalLine->tk.pin   = D5;   //安全带,默认端口为D5     //摩托车头盔
1020   1          if(pSignalLine->zbs.pin == 0)     pSignalLine->zbs.pin  = D17;  //左后视镜,默认端口为D17    //摩托车左把手
1021   1          if(pSignalLine->ybs.pin == 0)     pSignalLine->ybs.pin  = D19;  //内后视镜,默认端口为D19    //摩托车右把手
1022   1          if(pSignalLine->zjtb.pin == 0)    pSignalLine->zjtb.pin = D6;   //车门,默认端口为D6       //摩托车左脚踏板
1023   1          if(pSignalLine->yjtb.pin == 0)    pSignalLine->yjtb.pin = D16;  //雨刷,默认端口为D16        //摩托车右脚踏板
1024   1        #endif
1025   1          
1026   1      
1027   1          
1028   1      }
1029          //========================================================================
1030          // 函数: void GetDataPack(u8 *pData，u16 lenth)
1031          // 描述: 获取按照通讯协议的打包数据.
1032          // 参数: pData指向发给串口的数据数组,lenth需要获取的数据长度.
1033          // 返回: 无.
1034          // 版本: V1.0, 2022-10-17
1035          //========================================================================
1036          void GetBaseBoardDataPack(u8 pDatabuf[], u16 lenth)
1037          {
1038   1            
1039   1            static xdata u8 count=0;
1040   1        
1041   1      #ifdef  STC15W4K48S4    
1042   1        
1043   1            GetHSShockSensor_value(HS_BUMP_USART,&SignalLine);//更新碰杆数据
1044   1            Get24GShockSensor_value(BUMP_24G_USART);//更新碰杆数据
1045   1            GetTiltSensor_value(TILT_Q_USART,&Tilt[PLACE_Q_AXLE]);//采集前轴数据
1046   1            GetTiltSensor_value(TILT_H_USART,&Tilt[PLACE_H_AXLE]);//采集后轴数据
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 18  

1047   1            GetTiltSensor_value(TILT_G_USART,&Tilt[PLACE_G_AXLE]);//采集挂轴数据
1048   1            GetTiltSensor_value(TILT_MTC_USART,&Tilt[PLACE_MTC_AXLE]);  //采集二轮摩托车倾角数据
1049   1            GetTiltSensor_value(TILT_ALL_USART,Tilt); //采集汇总后的倾角数据
1050   1      
1051   1      #endif
1052   1        
1053   1            pDatabuf[0] |= (jiaosha(&SignalLine) << 0);             //脚杀
1054   1            pDatabuf[0] |=  (lihe(&SignalLine) << 1);               //离合器        
1055   1            pDatabuf[0] |=  (jinguang(&SignalLine) << 2);           //近光灯
1056   1            pDatabuf[0] |=  (yuanguang(&SignalLine) << 3);          //远光灯  
1057   1            pDatabuf[0] |=  (youzhuanxiangdeng(&SignalLine) << 4);  //右转向      
1058   1            pDatabuf[0] |=  (zuozhuanxiangdeng(&SignalLine) << 5);  //左转向
1059   1            pDatabuf[0] |=  (shousha(&SignalLine)<<6);              //手刹
1060   1            pDatabuf[0] |=  (zuoyitiaojie(&SignalLine)<<7);         //座椅
1061   1            
1062   1            pDatabuf[1] |=  (laba(&SignalLine) << 0);       //喇叭
1063   1            pDatabuf[1] |=  (daochedeng(&SignalLine) << 2); //倒车灯开关    
1064   1            pDatabuf[1] |=  (xiaodeng(&SignalLine) << 3);   //小灯
1065   1            pDatabuf[1] |=  (shijing(&SignalLine) << 4);    //双闪
1066   1            pDatabuf[1] |=  (anquandai(&SignalLine) << 5);  //安全带开关    
1067   1            pDatabuf[1] |=  (qidong(&SignalLine) << 6);     //启动开关
1068   1            pDatabuf[1] |=  (xihuo(&SignalLine) << 7);      //发动机转速
1069   1        
1070   1            pDatabuf[2] |=  chemen(&SignalLine);    //车门
1071   1            pDatabuf[2] |=  dangwei(&SignalLine);   //挡位
1072   1      
1073   1            pDatabuf[3] = 0;      //车速
1074   1            pDatabuf[4] |=  (u8)zhuansucount(&SignalLine);      //发动机转速低八位   
1075   1            pDatabuf[5] |=  (u8)zhuansucount(&SignalLine)>>8;   //发动机转速高八位
1076   1            
1077   1            pDatabuf[6] |=  (kongdang(&SignalLine) << 0);   //空挡
1078   1            pDatabuf[6] |=  (zuoyiyali(&SignalLine) << 3);  //座椅开关
1079   1            
1080   1            pDatabuf[7] |=  (yushua(&SignalLine) << 0);     //雨刷
1081   1            pDatabuf[7] |=  (wudeng(&SignalLine) << 1);     //雾灯
1082   1            pDatabuf[7] |=  (neihoushi(&SignalLine) << 2);  //内后视
1083   1            pDatabuf[7] |=  (zuohoushi(&SignalLine) << 3);  //后视左
1084   1            pDatabuf[7] |=  (jinguang(&SignalLine) << 4);   //大灯
1085   1            pDatabuf[7] |=  (yuanguang(&SignalLine) << 4);  //大灯
1086   1            pDatabuf[7] |=  (fushache(&SignalLine) << 5);   //副刹
1087   1            pDatabuf[7] |=  (qidong(&SignalLine) << 6);     //启动
1088   1            //pDatabuf[8]=0;      //红绿灯状态
1089   1            //pDatabuf[9]=0;      //异常状态
1090   1      
1091   1            pDatabuf[10]  = raoche1(&SignalLine); //左前绕车
1092   1            pDatabuf[11]  = raoche2(&SignalLine); //左后绕车
1093   1            pDatabuf[12]  = raoche1(&SignalLine); //右前绕车
1094   1            pDatabuf[13]  = raoche3(&SignalLine); //右后绕车
1095   1      
1096   1            //pDatabuf[14]  = 0;      //里程计数高位//计数器0
1097   1            //pDatabuf[15]  = 0;      //里程计数低位//计数器0
1098   1            
1099   1            //*pDatabuf[16] = 0;      //备用
1100   1            pDatabuf[17]  = (u8)BOARD_NO >> 8;  //板号高位
1101   1            pDatabuf[18]  = (u8)BOARD_NO;       //板号低位
1102   1            
1103   1            pDatabuf[19]  = 0;      //汽车前轴左侧超声波传感器对地面的距离（单位厘米）
1104   1            pDatabuf[20]  = 0;      //汽车前轴右侧超声波传感器对地面的距离（单位厘米）
1105   1            pDatabuf[21]  = 0;      //汽车后轴左侧超声波传感器对地面的距离（单位厘米）
1106   1            pDatabuf[22]  = 0;      //汽车后轴右侧超声波传感器对地面的距离（单位厘米）
1107   1            pDatabuf[23]  = 0;      //牵引车中轴左侧超声波传感器对地面的距离（单位厘米）
1108   1            pDatabuf[24]  = 0;      //牵引车中轴右侧超声波传感器对地面的距离（单位厘米）
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 19  

1109   1            
1110   1            pDatabuf[25]  = 0;        //训练圈数计数高位
1111   1            pDatabuf[26]  = 0;        //训练圈数计数低位
1112   1            
1113   1            pDatabuf[27]  = 0;        //车速高位
1114   1            pDatabuf[28]  = 0;        //车速低位
1115   1            pDatabuf[29]  = 0;        //离合AD值
1116   1            pDatabuf[30]  = 0;        //油门AD值
1117   1            
1118   1            pDatabuf[31]    |=  (yaoshimen(&SignalLine) << 0);      //钥匙开关
1119   1            pDatabuf[31]    |=  (chuangdong(&SignalLine) << 1);     //闯动开关
1120   1            
1121   1      #ifdef  STC15W4K48S4  
1122   1            pDatabuf[31]    |=  (toukui(&SignalLine) << 2);       //头盔（1=戴上）//摩托车
1123   1            pDatabuf[31]    |=  (zuobashou(&SignalLine) << 3);    //左把手（1=握上）//摩托车
1124   1            pDatabuf[31]    |=  (youbashou(&SignalLine) << 4);    //右把手（1=握上）//摩托车
1125   1            pDatabuf[31]    |=  (zuojiaotaban(&SignalLine) << 5);     //左踏板（1=踩上）//摩托车
1126   1            pDatabuf[31]    |=  (youjiaotaban(&SignalLine) << 6);     //右踏板（1=踩上）//摩托车
1127   1      #endif
1128   1            //*pDatabuf[31]   |=  (youmentaban(&SignalLine) << 7);  //1=油门踏板 
1129   1            
1130   1            
1131   1            pDatabuf[32]    = FIRMWARE_NUM;     //车载单片机固件号
1132   1            //*pDatabuf[33]   = 0;              //方向盘转角
1133   1      
1134   1            pDatabuf[34]    |=  (DBQ_LeftFront(&SignalLine)<<7);    //单边桥左前轮信号    （1=不在桥上，0=在桥上）
1135   1            pDatabuf[34]    |=  (DBQ_LeftRear(&SignalLine)<<6);     //单边桥左后轮信号    （1=不在桥上，0=在桥上）
1136   1            pDatabuf[34]    |=  (DBQ_RightFront(&SignalLine)<<5);   //单边桥右前轮信号    （1=不在桥上，0=在桥上）
1137   1            pDatabuf[34]    |=  (DBQ_RightRear(&SignalLine)<<4);    //单边桥右后轮信号    （1=不在桥上，0=在桥上）
1138   1            pDatabuf[34]    |=  (DBQ_LeftMiddle(&SignalLine)<<3);   //单边桥左挂车轮信号  （1=不在桥上，0=在桥上）
1139   1            pDatabuf[34]    |=  (DBQ_RightMiddle(&SignalLine)<<2);  //单边桥右挂车轮信号  （1=不在桥上，0=在桥上）
1140   1            //*pDatabuf[34]   |=  ((gaosujingshi()&0x01)<<1);     //1=高速警示标志
1141   1            //*pDatabuf[34]   |=  ((gaosuanquan()&0x01)<<0);      //1=高速安全区域//无锡检测使用
1142   1      #ifdef  STC15W4K48S4  
1143   1            
1144   1            pDatabuf[35]      =   pilepole.name;        //项目类型--01桩考，02限宽门，03牵引车桩考，04连续障碍，05单边桥
1145   1            pDatabuf[36]      =   pilepole.number;      //项目编号01，02，03....
1146   1            pDatabuf[37]      =   (u8)pilepole.value;   //碰杆位置01，02，03，04，05，06...（00=无碰杆）
1147   1        
1148   1            //*pDatabuf[38]   = 0;    //接近开关
1149   1            //*pDatabuf[39]   = 0;    //科大讯飞语音状态，41正在合成，4F合成完毕，00空闲状态  
1150   1            pDatabuf[40]      = (char)Tilt[PLACE_Q_AXLE].Pitch; //单边桥车前Y轴数据（[有符号char]，取小数点后一位，*10
             -倍上传）
1151   1            pDatabuf[41]      = (char)Tilt[PLACE_H_AXLE].Pitch; //单边桥车后Y轴数据（[有符号char]，取小数点后一位，*10
             -倍上传）
1152   1            pDatabuf[42]      = (char)Tilt[PLACE_G_AXLE].Pitch; //单边桥车挂Y轴数据（[有符号char]，取小数点后一位，*10
             -倍上传）
1153   1            pDatabuf[43]      = (char)Tilt[PLACE_MTC_AXLE].RollL;   //（二轮摩托）车身Y轴原始数据-低位 （横滚角，右倾为
             -正：右低左高，正。）
1154   1            pDatabuf[44]      = (char)Tilt[PLACE_MTC_AXLE].RollH;   //（二轮摩托）车身Y轴原始数据-高位
1155   1            pDatabuf[45]      = (char)Tilt[PLACE_MTC_AXLE].PitchL;    // (二轮摩托）车身X轴原始数据-低位 （俯仰角，仰为
             -）
1156   1            pDatabuf[46]      = (char)Tilt[PLACE_MTC_AXLE].PitchH;    //（二轮摩托）车身X轴原始数据-高位
1157   1      #endif      
1158   1            pDatabuf[47]      =   ID_LENTH; //主板序列号字节数（便于以后其他系列升级）
1159   1      //      pDatabuf[48]    =   localid[0];
1160   1      //      pDatabuf[49]    =   localid[1];
1161   1      //      pDatabuf[50]    =   localid[2];
1162   1      //      pDatabuf[51]    =   localid[3];
1163   1      //      pDatabuf[52]    =   localid[4];
1164   1      //      pDatabuf[53]    =   localid[5];
1165   1      //      pDatabuf[54]    =   localid[6];
C51 COMPILER V9.56.0.0   SIGNAL                                                            11/15/2022 14:33:07 PAGE 20  

1166   1      
1167   1            pDatabuf[55]    |=  (guanchayibiao(&SignalLine) << 0);//观察仪表盘
1168   1            
1169   1            pDatabuf[lenth-2]   = count++;    //数据标签为数据长度的倒数第二位,每次增加1  
1170   1            
1171   1            Checksum(pDatabuf,lenth);//计算校验和     
1172   1      } 
1173          
1174          
1175          
1176          
1177          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4928    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    359      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
