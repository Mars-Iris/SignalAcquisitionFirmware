C51 COMPILER V9.56.0.0   BSP_GPIO                                                          11/15/2022 13:44:44 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE BSP_GPIO
OBJECT MODULE PLACED IN .\Objects\bsp_gpio.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bsp\bsp_gpio.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\bsp_gpio.lst) TABS(2) OBJECT(.\Objects\bsp_gpio.obj)

line level    source

   1          
   2          #include  "./User/includes.h"
   3          #include  <stdio.h>
   4          #include  <string.h>
   5          
   6          #ifdef  STC15W4K48S4  
   7          xdata PengGanSignalTypeDef  pgxd[4];//碰杆消抖
   8          #endif
   9          //========================================================================
  10          // 函数: void BSP_GPIO_Init(void)
  11          // 描述: 初始化主板IO口.全部初始化为：上拉准双向口
  12          // 版本: V1.0, 2022-10-17
  13          //========================================================================
  14          void BSP_GPIO_Init(void)
  15          {
  16   1        GPIO_InitTypeDef  GPIO_InitStructure;       //结构定义
  17   1        
  18   1        GPIO_InitStructure.Pin  = GPIO_Pin_All;     //指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7, 或操作
  19   1        GPIO_InitStructure.Mode = GPIO_PullUp;      //指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO
             -_OUT_PP
  20   1        
  21   1        GPIO_Inilize(GPIO_P0,&GPIO_InitStructure);  //初始化GPIO_P0
  22   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);  //初始化GPIO_P1
  23   1        GPIO_Inilize(GPIO_P2,&GPIO_InitStructure);  //初始化GPIO_P2
  24   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);  //初始化GPIO_P3
  25   1        GPIO_Inilize(GPIO_P4,&GPIO_InitStructure);  //初始化GPIO_P4
  26   1        
  27   1      }
  28          //========================================================================
  29          // 函数: void BSP_Zhuansu_Init(void)
  30          // 描述: 初始化定时器0为计数模式，对转速脉冲计数
  31          // 版本: V1.0, 2022-10-17
  32          //========================================================================
  33          void BSP_ZhuansuCount_Init(void)
  34          {
  35   1          TMOD |= 0x05; //设置定时器0为计数器模式//对转速脉冲计数
  36   1          TH0=0;        //计数器清零
  37   1          TL0=0;        //计数器清零
  38   1          TR0=1;        //计数器0开始计数
  39   1      }
  40          //========================================================================
  41          // 函数: u8 BSP_GetGpioStatus(u8 pin)
  42          // 描述: 读取输入管脚电平值.此函数与硬件电路相关联
  43          // 参数: 板载输入口编号，取值D1--D32.
  44          // 返回: 输入口电平值.0或者1
  45          // 版本: V1.0, 2022-10-17
  46          //========================================================================
  47          static u8 BSP_GetGpioStatus(u8 pin)//查询对应的IO口状态
  48          {
  49   1        switch(pin)
  50   1        {
  51   2      #ifdef  STC12C5A60S2  
                  case D1:    return(P00);
                  case D2:    return(P01);
C51 COMPILER V9.56.0.0   BSP_GPIO                                                          11/15/2022 13:44:44 PAGE 2   

                  case D3:    return(P02);
                  case D4:    return(P03);
                  case D5:    return(P04);
                  case D6:    return(P05);
                  case D7:    return(P06);
                  case D8:    return(P07);
                  case D9:    return(P27);
                  case D10:   return(P26);
                  case D11:   return(P25);
                  case D12:   return(P24);
                  case D13:   return(P23);
                  case D14:   return(P22);
                  case D15:   return(P21);
                  case D16:   return(P20);
                  case D17:   return(P10);
                  case D18:   return(P11);
                  case D19:   return(P12);
                  case D20:   return(P13);
                  case D21:   return(P14);
                  case D22:   return(P15);
                  case D23:   return(P16);
                  case D24:   return(P17);
                  case D25:   return(P32);
                  case D26:   return(P33);
                  case D27:   return(P34);
                  case D28:   return(P35);
                  case D29:   return(P36);
                  case D30:   return(P37); 
                  case D31:   return(P47);
                  case D32:   return(P46);
                  case D33:   return(P45);
                  case D34:   return(P44); 
                  case D35:   return(P44);
              #endif
  88   2      #ifdef  STC15W4K48S4  
  89   2          case D1:    return(P45);
  90   2          case D2:    return(P27);
  91   2          case D3:    return(P02);
  92   2          case D4:    return(P26);
  93   2          case D5:    return(P03);
  94   2          case D6:    return(P25);
  95   2          case D7:    return(P04);
  96   2          case D8:    return(P24);
  97   2          case D9:    return(P05);
  98   2          case D10:   return(P23);
  99   2          case D11:   return(P06);
 100   2          case D12:   return(P22);
 101   2          case D13:   return(P07);
 102   2          case D14:   return(P21);
 103   2          case D15:   return(P20);
 104   2          case D16:   return(P44);
 105   2          case D17:   return(P12);
 106   2          case D18:   return(P42);
 107   2          case D19:   return(P13);
 108   2          case D20:   return(P41);
 109   2          case D21:   return(P14);
 110   2          case D22:   return(P37);
 111   2          case D23:   return(P15);
 112   2          case D24:   return(P36);
 113   2          case D25:   return(P35);
 114   2          case D26:   return(P34);
 115   2          case D27:   return(P33);
C51 COMPILER V9.56.0.0   BSP_GPIO                                                          11/15/2022 13:44:44 PAGE 3   

 116   2          case D28:   return(P32);
 117   2          case D29:   return(P54);
 118   2          case D30:   return(P55); 
 119   2          case D31:   return(P55);
 120   2      #endif
 121   2          
 122   2          default: 
 123   2                      return(0);
 124   2        }
 125   1      }
 126          //========================================================================
 127          // 函数: u8 BSP_ReadInputDataBit(SignalTypeDef *pSignal)
 128          // 描述: 读取输入管脚电平值.
 129          // 参数: SignalTypeDef为指向信号结构体的指针.
 130          // 返回: 返回TURE，或FALSE.
 131          // 版本: V1.0, 2022-10-17
 132          //========================================================================
 133          u8 BSP_ReadInputDataBit(SignalTypeDef *pSignal)
 134          {
 135   1        xdata u8 status = 0;
 136   1        xdata u8 signalstatus = BSP_GetGpioStatus(pSignal->pin);//获取单片机的管脚输入状态
 137   1        if(pSignal->falling_ed == 255)  pSignal->falling_ed = 0;//此处仅为兼容老版本的程序，未增加该参数的情况
 138   1      
 139   1        if(pSignal->stateflag == 0)
 140   1        {
 141   2          if (signalstatus == pSignal->modle)//判断信号是否开启
 142   2          {
 143   3            pSignal->times = 0;
 144   3            status = TURE;  
 145   3          }
 146   2          else if(pSignal->times < pSignal->rising_ed) //信号抖动与延时处理
 147   2          {
 148   3            (pSignal->times)++;
 149   3            status = TURE;  
 150   3          } 
 151   2          else 
 152   2          {
 153   3            pSignal->stateflag = 1;
 154   3            status = FALSE; 
 155   3          }
 156   2        }
 157   1        else 
 158   1        {
 159   2          if (signalstatus != pSignal->modle)//获取相应的状态
 160   2          {
 161   3            pSignal->times = 0;
 162   3            status = FALSE;
 163   3          }
 164   2          else if(pSignal->times < pSignal->falling_ed) //信号抖动与延时处理
 165   2          {
 166   3            (pSignal->times)++;
 167   3            status = FALSE;
 168   3          } 
 169   2          else 
 170   2          {
 171   3            pSignal->stateflag = 0;
 172   3            status = TURE; 
 173   3          }   
 174   2        }
 175   1        #ifdef DEBUG1
                if(pSignal->pin ==12)
                {
C51 COMPILER V9.56.0.0   BSP_GPIO                                                          11/15/2022 13:44:44 PAGE 4   

                        printf("pin = %b02u  modle  = %b02u  times = %b02u rising_ed = %b02u falling_ed = %b02u\r\n"\
                              ,pSignal->pin,pSignal->modle,pSignal->times,pSignal->rising_ed,pSignal->falling_ed);
                        printf("gpiovalue = %b02d.  ",signalstatus);
                        printf("output = %b02d.\r\n",status);
                }
                #endif  
 184   1        return(status);
 185   1      }
 186          //========================================================================
 187          // 函数:BSP_ReadMultipleDataBit(MultSignalTypeDef *pSignal,u8 pin)
 188          // 描述: 读取一个传感器多个信号线
 189          // 参数: MultSignalTypeDef指向地址，pin读的是哪一根信号线.
 190          // 返回: 返回TURE，或FALSE.
 191          // 版本: V1.0, 2022-10-17
 192          //========================================================================
 193          u8 BSP_ReadMultipleDataBit(MultSignalTypeDef *pSignal,u8 offset)
 194          {
 195   1        xdata u8 pin = *(u8 *)((u8 *)pSignal + offset  - 1);
 196   1        xdata u8 status = 0;
 197   1        xdata u8 signalstatus = BSP_GetGpioStatus(pin);//获取单片机的管脚输入状态
 198   1        xdata u8 flag = 0;//信号反转标志
 199   1        
 200   1        flag = (((pSignal->stateflag) >> (offset-1)) & (0x01));//得到标志状态
 201   1        
 202   1        pSignal->times = pSignal->counts[offset-1];//获取延时计数器的值
 203   1        
 204   1        if(pSignal->falling_ed == 255)  pSignal->falling_ed = 0;//此处仅为兼容老版本的程序，未增加该参数的情况
 205   1          
 206   1        if(flag == 0)
 207   1        {
 208   2          if (signalstatus == pSignal->modle)//判断信号是否开启
 209   2          {
 210   3            pSignal->times = 0;
 211   3            status = TURE;
 212   3          }
 213   2          else if(pSignal->times < pSignal->rising_ed) //信号抖动与延时处理
 214   2          {
 215   3            pSignal->times++;
 216   3            status = TURE;
 217   3          } 
 218   2          else 
 219   2          {
 220   3            flag = 1;
 221   3            status = FALSE; 
 222   3          }
 223   2        }
 224   1        else 
 225   1        {
 226   2          if (signalstatus != pSignal->modle)//获取相应的状态
 227   2          {
 228   3            pSignal->times = 0;
 229   3            status = FALSE;
 230   3          }
 231   2          else if(pSignal->times < pSignal->falling_ed) //信号抖动与延时处理
 232   2          {
 233   3            pSignal->times++;
 234   3            status = FALSE;
 235   3          } 
 236   2          else 
 237   2          {
 238   3            flag = 0;
 239   3            status = TURE; 
C51 COMPILER V9.56.0.0   BSP_GPIO                                                          11/15/2022 13:44:44 PAGE 5   

 240   3          }   
 241   2        }
 242   1        #ifdef DEBUG1
                  if(pin == 13)
                  {
                  printf("pin = %b02u  modle  = %b02u  times = %b02u rising_ed = %b02u falling_ed = %b02u\r\n"\
                              ,pin,pSignal->modle,pSignal->times,pSignal->rising_ed,pSignal->falling_ed);
                  printf("gpiovalue = %b02d.  ",signalstatus);
                  printf("output = %b02d.\r\n",status);
                  }
                
                #endif  
 252   1        pSignal->counts[offset-1]=pSignal->times;//保存本次延时计数器的值
 253   1        
 254   1        pSignal->stateflag |= (flag << offset-1);
 255   1          
 256   1        return(status);
 257   1      }
 258          #ifdef  STC15W4K48S4  
 259          //========================================================================
 260          // 函数:BSP_ReadBumpDataBit(SignalTypeDef *pSignal,u8 group,u8 valuebit,u8 offset)
 261          // 描述: 碰杆传感器消抖
 262          // 参数: MultSignalTypeDef指向地址，u8 碰杆状态的value值 offset读的是哪一根信号线（从0开始）.
 263          // 返回: 返回TURE，或FALSE.
 264          // 版本: V1.0, 2022-10-17
 265          //========================================================================
 266          u8 BSP_ReadBumpDataBit(SignalTypeDef *pSignal,u8 group,u8 valuebit,u8 offset)
 267          {
 268   1        xdata u8 status = 0;
 269   1        xdata u8 signalstatus = valuebit;//获取输入状态
 270   1        
 271   1        xdata u8 flag = 0;//信号反转标志
 272   1        
 273   1        flag = (((pgxd[group].stateflag) >> offset) & (0x01));//得到标志状态
 274   1        
 275   1        pSignal->times = pgxd[group].times[offset];//获取延时计数器的值
 276   1        
 277   1        if(pSignal->falling_ed == 255)  pSignal->falling_ed = 0;//此处仅为兼容老版本的程序，未增加该参数的情况
 278   1          
 279   1        if(flag == 0)
 280   1        {
 281   2          if (signalstatus == TURE)//判断信号是否开启
 282   2          {
 283   3            pSignal->times = 0;
 284   3            status = TURE;
 285   3          }
 286   2          else if(pSignal->times < pSignal->rising_ed) //信号抖动与延时处理
 287   2          {
 288   3            pSignal->times++;
 289   3            status = TURE;
 290   3          } 
 291   2          else 
 292   2          {
 293   3            flag = 1;
 294   3            status = FALSE; 
 295   3          }
 296   2        }
 297   1        else 
 298   1        {
 299   2          if (signalstatus != TURE)//获取相应的状态
 300   2          {
 301   3            pSignal->times = 0;
C51 COMPILER V9.56.0.0   BSP_GPIO                                                          11/15/2022 13:44:44 PAGE 6   

 302   3            status = FALSE;
 303   3          }
 304   2          else if(pSignal->times < pSignal->falling_ed) //信号抖动与延时处理
 305   2          {
 306   3            pSignal->times++;
 307   3            status = FALSE;
 308   3          } 
 309   2          else 
 310   2          {
 311   3            flag = 0;
 312   3            status = TURE; 
 313   3          }   
 314   2        }
 315   1        #ifdef DEBUG1
                  if(pin == 13)
                  {
                  printf("pin = %b02u  modle  = %b02u  times = %b02u rising_ed = %b02u falling_ed = %b02u\r\n"\
                              ,pin,pSignal->modle,pSignal->times,pSignal->rising_ed,pSignal->falling_ed);
                  printf("gpiovalue = %b02d.  ",signalstatus);
                  printf("output = %b02d.\r\n",status);
                  }
                
                #endif  
 325   1          
 326   1        pgxd[group].times[offset] = pSignal->times;//保存本次延时计数器的值
 327   1        
 328   1        if( flag == 0 )
 329   1        {
 330   2          pgxd[group].stateflag &= ~(u16)(1<< offset);//更新消抖处理结果
 331   2        }
 332   1        else 
 333   1          pgxd[group].stateflag |= (u16)(1<< offset);//更新消抖处理结果
 334   1        
 335   1        return(status);
 336   1      }
 337          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1190    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     72       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
