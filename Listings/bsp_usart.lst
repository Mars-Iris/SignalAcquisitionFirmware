C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE BSP_USART
OBJECT MODULE PLACED IN .\Objects\bsp_usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bsp\bsp_usart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\bsp_usart.lst) TABS(2) OBJECT(.\Objects\bsp_usart.obj)

line level    source

   1          #include "./User/includes.h"
   2          #include <stdio.h>
   3          #include <string.h>
   4          
   5          
   6            
   7          #ifdef  STC12C5A60S2  
                xdata UsartRxTypeDef Rx[2]; 
                xdata u8 Rx1_Buffer[COM_Rx_LENTH];
                xdata u8 Rx2_Buffer[COM_Rx_LENTH];
              #endif
  12          
  13          
  14          #ifdef  STC15W4K48S4  
  15            xdata UsartRxTypeDef Rx[4]; 
  16          //Îª½ÚÔ¼ÄÚ´æ£¬×öÔ¤±àÒë´¦Àí£¬½ö½«GPSµÄ´®¿Ú»º´æ·ÖÅä512×Ö½Ú£¬ÆäËûÎª128¸ö×Ö½Ú
  17            #if (GPS_USART == USART1)
                xdata u8 Rx1_Buffer[GPS_Rx_LENTH];
                xdata u8 Rx2_Buffer[COM_Rx_LENTH];
                xdata u8 Rx3_Buffer[COM_Rx_LENTH];
                xdata u8 Rx4_Buffer[COM_Rx_LENTH];
                  
                #elif (GPS_USART == USART2)
                xdata u8 Rx1_Buffer[COM_Rx_LENTH];
                xdata u8 Rx2_Buffer[GPS_Rx_LENTH];
                xdata u8 Rx3_Buffer[COM_Rx_LENTH];
                xdata u8 Rx4_Buffer[COM_Rx_LENTH];
                  
                #elif (GPS_USART == USART3)
  30            xdata u8 Rx1_Buffer[COM_Rx_LENTH];
  31            xdata u8 Rx2_Buffer[COM_Rx_LENTH];
  32            xdata u8 Rx3_Buffer[GPS_Rx_LENTH];
  33            xdata u8 Rx4_Buffer[COM_Rx_LENTH];
  34              
  35            #elif (GPS_USART == USART4)
                xdata u8 Rx1_Buffer[COM_Rx_LENTH];
                xdata u8 Rx2_Buffer[COM_Rx_LENTH];
                xdata u8 Rx3_Buffer[COM_Rx_LENTH];
                xdata u8 Rx4_Buffer[GPS_Rx_LENTH];
                #else 
                xdata u8 Rx1_Buffer[COM_Rx_LENTH];
                xdata u8 Rx2_Buffer[COM_Rx_LENTH];
                xdata u8 Rx3_Buffer[COM_Rx_LENTH];
                xdata u8 Rx4_Buffer[COM_Rx_LENTH];
                #endif
  46          #endif
  47          //========================================================================
  48          // º¯Êý:char putchar(char ch) printfÖØ¶¨Ïòº¯Êý
  49          // ÃèÊö:printfÖØ¶¨Ïòµ½usart1
  50          // ²ÎÊý£º
  51          // °æ±¾: 
  52          //========================================================================
  53          char putchar(char ch)  //º¯ÊýÄ¬ÈÏµÄ£¬ÔÚÊ¹ÓÃprintfº¯ÊýÊ±×Ô¶¯µ÷ÓÃ
  54          {
C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 2   

  55   1        USART_SendData(CONSOLE_USART,(char)ch);
  56   1        return ch;
  57   1      }
  58          //========================================================================
  59          // º¯Êý:BSP_Usart_Init(unsigned char USARTx,unsigned long bote)
  60          // ÃèÊö: ³õÊ¼»¯´®¿Ú
  61          // ²ÎÊý£ºUSARTx¶Ë¿ÚºÅ£¬bote²¨ÌØÂÊ
  62          // °æ±¾: V1.0, 2022-10-17
  63          //========================================================================
  64          void BSP_Usart_Init(unsigned char USARTx,unsigned long bote)
  65          {
  66   1        COMx_InitDefine   COMx_InitStructure;                 //½á¹¹¶¨Òå
  67   1        
  68   1        if(USARTx == USART1)
  69   1        { 
  70   2          Rx[USARTx-1].pStart = Rx1_Buffer;
  71   2          Rx[USARTx-1].pEnd  = Rx1_Buffer + sizeof(Rx1_Buffer) -1;
  72   2          Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
  73   2          Rx[USARTx-1].overflow_flag = 0;
  74   2          memset(Rx1_Buffer,0,sizeof(Rx1_Buffer));
  75   2          
  76   2          COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;       //Ê¹ÓÃ²¨ÌØÂÊ·¢ÉúÆ÷,   BRT_Timer1, BRT_Timer2 
  77   2        }
  78   1        else if(USARTx == USART2)
  79   1        {
  80   2          Rx[USARTx-1].pStart = Rx2_Buffer;
  81   2          Rx[USARTx-1].pEnd  = Rx2_Buffer + sizeof(Rx2_Buffer) -1;
  82   2          Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
  83   2          Rx[USARTx-1].overflow_flag = 0;
  84   2          memset(Rx2_Buffer,0,sizeof(Rx2_Buffer));
  85   2          
  86   2          COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;       //Ê¹ÓÃ²¨ÌØÂÊ·¢ÉúÆ÷,   BRT_Timer2 (×¢Òâ: ´®¿Ú2¹Ì¶¨Ê¹Ó
             -ÃBRT_Timer2)
  87   2        }
  88   1      #ifdef  STC15W4K48S4  
  89   1        else if(USARTx == USART3)
  90   1        {
  91   2          Rx[USARTx-1].pStart = Rx3_Buffer;
  92   2          Rx[USARTx-1].pEnd  = Rx3_Buffer + sizeof(Rx3_Buffer) -1;
  93   2          Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
  94   2          Rx[USARTx-1].overflow_flag = 0;
  95   2          memset(Rx3_Buffer,0,sizeof(Rx3_Buffer));
  96   2          
  97   2          COMx_InitStructure.UART_BRT_Use   = BRT_Timer3;       //Ê¹ÓÃ²¨ÌØÂÊ·¢ÉúÆ÷,   BRT_Timer2, BRT_Timer3 
  98   2        }
  99   1        else if(USARTx == USART4)
 100   1        {
 101   2          Rx[USARTx-1].pStart = Rx4_Buffer;
 102   2          Rx[USARTx-1].pEnd  = Rx4_Buffer + sizeof(Rx4_Buffer) -1;
 103   2          Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
 104   2          Rx[USARTx-1].overflow_flag = 0;
 105   2          memset(Rx4_Buffer,0,sizeof(Rx4_Buffer));
 106   2          
 107   2          COMx_InitStructure.UART_BRT_Use   = BRT_Timer4;       //Ê¹ÓÃ²¨ÌØÂÊ·¢ÉúÆ÷,   BRT_Timer2, BRT_Timer4 
 108   2        }
 109   1      #endif
 110   1        else 
 111   1        {
 112   2          return;
 113   2        }
 114   1        COMx_InitStructure.UART_BaudRate  = bote;             //²¨ÌØÂÊ, Ò»°ã 110 ~ 115200
 115   1        COMx_InitStructure.UART_Interrupt = ENABLE;           //ÖÐ¶ÏÔÊÐí,   ENABLE»òDISABLE
C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 3   

 116   1        USART_Configuration(USARTx, &COMx_InitStructure);     //³õÊ¼»¯´®¿Ú1 USART1,USART2
 117   1      }
 118          //========================================================================
 119          // º¯Êý:u16 BSP_GetUsartRxBuffer(u8 USARTx,u8 *RxBuffer,u16 *lenth)
 120          // ÃèÊö: ¶ÁÈ¡´®¿Ú»º´æÖÐµÄÊý¾Ý£¬ÐøÐ´£¬ÈçÐ­ÒéÆ¥Åä³É¹¦£¬lenthÐèÈí¼þÇåÁã
 121          // ²ÎÊý£ºu8 USARTxÎª¶Ë¿ÚºÅ£¬RxBuffer»º´æÇøÖ¸Õë,»º´æÇøµÄ³¤¶È
 122          // ·µ»Ø£º¶ÁÈ¡µÄÊý¾Ý³¤¶È
 123          // °æ±¾: V1.0, 2022-10-17
 124          //========================================================================
 125          u16 BSP_GetUsartRxBuffer(u8 USARTx,u8 *pRxBuffer,u16 Rxlenth)
 126          {
 127   1        xdata u16 remaindlen = 0;   //Êý×éÊ£Óà¿Õ¼ä´óÐ¡£¬¼ìÑéÒç³öÊ±Ê¹ÓÃ
 128   1        xdata u16 lenth = 0;        //»º´æÈ¥Êý¾Ý³¤¶È
 129   1        xdata u16 i = 0;
 130   1        
 131   1        
 132   1        if(USARTx == DISABLE) //Ó²¼þ´®¿ÚÎ´³õÊ¼»¯
 133   1        { 
 134   2          return 0;//·µ»Ø0
 135   2        }
 136   1        
 137   1        remaindlen = (u16)(Rx[USARTx-1].pEnd - Rx[USARTx-1].pIn) + 1;//¼ÆËãÊ£Óà¿Õ¼ä´óÐ¡
 138   1        
 139   1        lenth = USART_ReadRxBuffer(USARTx,Rx[USARTx-1].pIn,remaindlen);//¶ÁÈ¡´®¿Ú½ÓÊÕµÄ»º´æÊý¾Ý
 140   1        
 141   1        Rx[USARTx-1].pIn = (u8 *)(Rx[USARTx-1].pIn + lenth);//½«Ö¸ÕëÒÆ¶¯µ½ÏÂÒ»´ÎÐèÒªÐ´ÈëÊý¾ÝµÄÎ»ÖÃ
 142   1        
 143   1        lenth = (u16)(Rx[USARTx-1].pIn - Rx[USARTx-1].pStart); //Êý¾Ý³¤¶È½ÓÐø
 144   1        
 145   1        if(Rx[USARTx-1].pIn >= Rx[USARTx-1].pEnd) //¼ì²éÊý×éÊÇ·ñÔ½½ç
 146   1        {
 147   2        
 148   2          BSP_ClearUsartRxBuffer(USARTx);//Èí¼þ×Ô¶¯Çå¿Õ»º´æÇøÓò
 149   2      
 150   2          printf("BSP_GetUsartRxBuffer:Index overflow!!!  USARTx = %b02d\r\n",USARTx);
 151   2          
 152   2          #ifdef DEBUG
                  printf("BSP_GetUsartRxBuffer:Index overflow!!!  USARTx = %b02d\r\n",USARTx);  
                  #endif  
 155   2          
 156   2          lenth = 0;//Èí¼þ×Ô¶¯Çå¿Õ»º´æÇøÓò
 157   2        }
 158   1      
 159   1        if(lenth >= Rxlenth)//Êý¾ÝÄÚÈÝ³¬¹ýÁËÐèÒªÐ´µÄ»º´æ¿Õ¼äÁË
 160   1        {
 161   2          lenth = Rxlenth;  //½Ø¶ÏÊý¾Ý
 162   2          
 163   2          printf("Rxlenth:Index overflow!!!  USARTx = %b02d\r\n",USARTx);
 164   2          
 165   2          for (i = 0;i < Rxlenth; i++) //Êý¾Ý¿½±´
 166   2          {
 167   3            *pRxBuffer++ = *(Rx[USARTx-1].pStart+i);  
 168   3          }
 169   2          BSP_ClearUsartRxBuffer(USARTx);//Èí¼þ×Ô¶¯Çå¿Õ»º´æÇøÓò
 170   2        }
 171   1        else
 172   1        {
 173   2          for (i = 0;i < lenth; i++) //Êý¾Ý¿½±´
 174   2          {
 175   3            *pRxBuffer++ = *(Rx[USARTx-1].pStart+i);  
 176   3          }
 177   2          
C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 4   

 178   2        }
 179   1        
 180   1        *pRxBuffer = '\0';         //½öÓÃÓÚºóÐø×Ö·û´®´¦ÀíÊ±×÷Îª½áÊø·ûºÅÊ¹ÓÃ
 181   1        
 182   1        return lenth;
 183   1        
 184   1      }
 185          //========================================================================
 186          // º¯Êý:u16 BSP_GetFormatRxBuffer(u8 USARTx,u8 *RxBuffer,u16 *lenth,u8 *cutstr)
 187          // ÃèÊö: »ñÈ¡´®¿Ú»º´æÖÐµÄÊý¾Ý£¬°´ÕÕ×îºóÒ»¸ö'\n'½øÐÐÇÐ¸î¶ÁÈ¡.
 188          // ²ÎÊý£ºu8 USARTxÎª¶Ë¿ÚºÅ£¬RxBuffer»º´æÇøÖ¸Õë,Rxlenth»º´æÇøµÄ³¤¶È,u8 ÒÔ*cutstr×÷ÎªÇÐ¸î×Ö·û´® cutlenth,ÊÇÇ
             -Ð¸î×Ö·ûµÄ³¤¶È
 189          // ·µ»Ø£º¶ÁÈ¡µÄÊý¾Ý³¤¶È
 190          // °æ±¾: V1.0, 2022-10-17
 191          //========================================================================
 192          u16 BSP_GetFormatRxBuffer(u8 USARTx,u8 *pRxBuffer,u16 Rxlenth,u8 *cutstr,u8 cutlenth)
 193          {
 194   1        xdata u16 lenth = 0;          //»º´æÊý¾Ý³¤¶È
 195   1        xdata u8  *pTemp     = NULL;
 196   1        xdata u8  *pStart    = NULL;
 197   1        xdata u8  *pcutstr    = NULL;
 198   1        xdata u8  i  = 0;
 199   1      
 200   1        
 201   1        if(USARTx == DISABLE) //Ó²¼þ´®¿ÚÎ´³õÊ¼»¯
 202   1        { 
 203   2          return 0;//·µ»Ø0
 204   2        }
 205   1        
 206   1        lenth = BSP_GetUsartRxBuffer(USARTx,pRxBuffer,Rxlenth);//¶ÁÈ¡»º´æÊý¾Ý
 207   1        
 208   1        pcutstr = ByteArrayCompar_r(pRxBuffer,lenth,cutstr,cutlenth);//ÕÒµ½ÇÐ¸î×Ö·û´®µÄÎ»ÖÃ£¬´ÓºóÍùÇ°ÕÒ¡£
 209   1        
 210   1        if(pcutstr == NULL)//Î´²éÑ¯µ½ÇÐ¸î×Ö·û
 211   1        {
 212   2          memset(pRxBuffer,0,Rxlenth);//Çå¿Õ»º´æÊý¾Ý
 213   2          
 214   2          //printf("BSP_GetFormatRxBuffer lenth = %h04d\r\n",lenth);
 215   2          
 216   2          lenth = 0;//¶ÁÈ¡³¤¶ÈÎª0
 217   2          
 218   2          
 219   2          return lenth;//·µ»Ø0
 220   2        }
 221   1        //´¦Àí»º´æÇøpRxBufferµÄÊý¾Ý
 222   1        if(*(cutstr+cutlenth-1) == '\n')//Èç¹ûÓÐ»»ÐÐ·û²¢ÇÒÊÇÄ©Î²ÇÐ·Ö
 223   1        {
 224   2          //printf("BSP_GetFormatRxBuffer lenth = %h04d\r\n",lenth);
 225   2          
 226   2          pcutstr = (u8 *)(pcutstr +1);//Ìø¹ýÇÐ¸î×Ö·û
 227   2          
 228   2        }
 229   1        lenth = (u16)(pcutstr - pRxBuffer);//Êý¾Ý³¤¶È£¬·µ»Ø¸øµ÷ÓÃÕß
 230   1        
 231   1        memset(pcutstr,0,(u16)(Rxlenth - lenth));//Çå³ý¶àÓàµÄÊý¾Ý£¬·µ»Ø¸øµ÷ÓÃÕß
 232   1        
 233   1        //´¦Àí»º´æÇøRxµÄÊý¾Ý
 234   1        pStart = Rx[USARTx-1].pStart;
 235   1        
 236   1        pTemp = (u8 *)(pStart + lenth);
 237   1        
 238   1        while (pTemp  < Rx[USARTx-1].pIn)
C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 5   

 239   1        {
 240   2            *pStart++ = *pTemp++;    //½«Ê£ÏÂµÄÊý¾ÝÒÆµ½»º´æÇøµÄÊ×µØÖ· 
 241   2        }
 242   1        memset(pStart,0,(u16)(Rx[USARTx-1].pEnd - pStart +1));//Çå³ýºóÐø»º´æ
 243   1        
 244   1        Rx[USARTx-1].pIn = pStart;
 245   1        
 246   1        return lenth;
 247   1      }
 248          //========================================================================
 249          // º¯Êý:void BSP_ClearUsartRxBuffer(u8 USARTx)
 250          // ÃèÊö: ÇåÀí´®¿Ú»º´æÊý¾Ý
 251          // ²ÎÊý£ºu8 USARTxÎª¶Ë¿ÚºÅ
 252          // °æ±¾: V1.0, 2022-10-17
 253          //========================================================================
 254          void BSP_ClearUsartRxBuffer(u8 USARTx)
 255          {
 256   1        xdata u16 lenth = 0;
 257   1      
 258   1        if(USARTx == DISABLE) return;//Ó²¼þ´®¿ÚÎ´¿ªÆô
 259   1        
 260   1        lenth = (u16)(Rx[USARTx-1].pEnd - Rx[USARTx-1].pStart + 1);//¼ÆËã»º´æÇøµÄ×Ü³¤¶È
 261   1        
 262   1        memset(Rx[USARTx-1].pStart, 0,lenth);//»º´æÇøÇåÁã
 263   1        
 264   1        Rx[USARTx-1].pIn = Rx[USARTx-1].pStart;   //Ö¸Ïò»º´æÇøÊ×µØÖ·
 265   1        
 266   1         #ifdef DEBUG
                  printf("Rx[%b02d]Clear,OK!\r\n",(USARTx-1));
                 #endif
 269   1      }
 270          //========================================================================
 271          // º¯Êý:WaitForTISignal(u8 USARTx)
 272          // ÃèÊö: µÈ´ý´®¿ÚÊý¾Ý·¢ËÍÍê³É£¬×èÈûÄ£Ê½
 273          // ²ÎÊý£ºu8 USARTx´®¿ÚºÅ
 274          // °æ±¾: V1.0, 2022-10-17
 275          //========================================================================
 276          static void WaitForTISignal(u8 USARTx)
 277          {
 278   1        if(USARTx == USART1)
 279   1        {
 280   2          while(TI == 0); 
 281   2          TI = 0;
 282   2        }
 283   1        else if(USARTx == USART2)
 284   1        {
 285   2          while((S2CON & 2) == 0); 
 286   2          S2CON &= ~2;
 287   2        }
 288   1        #ifdef  STC15W4K48S4
 289   1        else if(USARTx == USART3)
 290   1        {
 291   2          while(TI3 ==0);
 292   2          CLR_TI3();
 293   2        }
 294   1        else if(USARTx == USART4)
 295   1        {
 296   2          while(TI4==0);
 297   2          CLR_TI4();   
 298   2        }
 299   1        #endif
 300   1        else 
C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 6   

 301   1        {
 302   2          return;
 303   2        }
 304   1      }
 305          //========================================================================
 306          // º¯Êý:void USART_SendData(u8 USARTx,u8 ch)
 307          // ÃèÊö: ´®¿ÚÊý¾Ý·¢ËÍÄ£Ê½£¬²éÑ¯·½Ê½
 308          // ²ÎÊý£ºu8 USARTx´®¿ÚºÅ,u8 chÐèÒª·¢ËÍµÄÊý¾Ý
 309          // °æ±¾: V1.0, 2022-10-17
 310          //========================================================================
 311          void USART_SendData(u8 USARTx,u8 ch)
 312          {
 313   1        
 314   1        if(USARTx == DISABLE) //Ó²¼þ´®¿ÚÎ´³õÊ¼»¯
 315   1        { 
 316   2          return ;//Ö±½Ó·µ»Ø
 317   2        }
 318   1        switch(USARTx)
 319   1        {
 320   2          case USART1:
 321   2                      SBUF = ch;
 322   2                      break;
 323   2          case USART2:
 324   2                      S2BUF = ch;
 325   2                      break;
 326   2      #ifdef  STC15W4K48S4
 327   2          case USART3:
 328   2                      S3BUF = ch;
 329   2                      break;    
 330   2          case USART4:
 331   2                      S4BUF = ch;
 332   2                      break;  
 333   2      #endif
 334   2          default:
 335   2                      break;
 336   2          
 337   2        }
 338   1        WaitForTISignal(USARTx);//µÈ´ýÊý¾Ý´«ÊäÍê³É
 339   1      }
 340          //========================================================================
 341          // º¯Êý:void USART_Sendbuffer(u8 USARTx,const u8 *ch, u16 lenth)
 342          // ÃèÊö: ´®¿ÚÊý¾Ý·¢ËÍÄ£Ê½£¬²éÑ¯·½Ê½
 343          // ²ÎÊý£ºu8 USARTx´®¿ÚºÅ,u8 chÐèÒª·¢ËÍµÄÊý¾Ý,lenth»º´æÇøµÄ³¤¶È
 344          // °æ±¾: V1.0, 2022-10-17
 345          //========================================================================
 346          void USART_Sendbuffer(u8 USARTx,const u8 *ch, u8 lenth)
 347          {
 348   1        unsigned char i = 0;
 349   1        //printf("USART_Sendbuffer\r\n");
 350   1        for (i=0;i<lenth;i++)
 351   1        {
 352   2          USART_SendData(USARTx,*ch++);
 353   2        }
 354   1        
 355   1      }
 356          
 357          //========================================================================
 358          // º¯Êý:printf_buffer(const char *name,const u8 *pbuffer,u16 lenth)
 359          // ÃèÊö: ¸ñÊ½»¯´ðÓ¦Êý×éÄÚÈÝ
 360          // ²ÎÊý£ºnameÎª´òÓ¡³öÀ´µÄÊý×éÃû³Æ,pbufferÎªÊý×éÃû³Æ£¬lenthÎª´òÓ¡Êý×éÇ°¶àÉÙ¸öÔªËØ
 361          // °æ±¾: V1.0, 2022-10-17
 362          //========================================================================
C51 COMPILER V9.56.0.0   BSP_USART                                                         11/15/2022 13:44:45 PAGE 7   

 363          #ifdef DEBUG1
              void printf_buffer(const char *name,const u8 *pbuffer,u16 lenth)
              {
                int i = 0;
                printf("%s:",name);
                for (i = 0; i < lenth; i++)
                {
                  printf("%b02X",*pbuffer++); 
                  printf(" ");      
                }
                printf("\r\n");
              }
              #endif
 376          //========================================================================
 377          // º¯Êý:HextoStr(const u8 *pbuffer,char *pStr,u16 lenth)
 378          // ÃèÊö: ½«×Ö·ûÊý×é×ª»»³É×Ö·û´®£¬
 379          // ²ÎÊý£ºpbufferÎª×Ö½ÚÊý×éÃû³Æ£¬pStrÐèÒª±£´æ×Ö·û´®µÄµØÖ·£¬lenthÎª×Ö½ÚÊý×éµÄ³¤¶È
 380          // °æ±¾: V1.0, 2022-10-17
 381          //========================================================================
 382          #ifdef  STC15W4K48S4  
 383          void HextoStr(const u8 *pbuffer,u8 *pStr,u16 lenth)
 384          {
 385   1        u16 i = 0;
 386   1        char temp[3] = "";
 387   1        for (i = 0; i < lenth; i++)
 388   1        {
 389   2          sprintf(temp,"%b02X",*pbuffer++);
 390   2          strcat(pStr,temp);
 391   2        }
 392   1        strcat(pStr,"\n");
 393   1      }
 394          #endif
 395          
 396          
 397          
 398          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2098    ----
   CONSTANT SIZE    =    112    ----
   XDATA SIZE       =    936      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      51
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
