C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\usart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\usart.lst) TABS(2) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "./User/includes.h"
   2          #include <stdio.h>
   3          #include <string.h>
   4          
   5          #ifdef  STC12C5A60S2  
              xdata volatile MessageQueue  Msg_RX[2];
              xdata volatile u8 Msg_Rx1Buffer[Q_BUF_LENTH];     //缓存区
              xdata volatile u8 Msg_Rx2Buffer[Q_BUF_LENTH];     //缓存区
              #endif
  10          
  11          #ifdef  STC15W4K48S4  
  12          xdata volatile MessageQueue  Msg_RX[4];
  13          //为节约内存，做预编译处理，仅将GPS的串口缓存分配512字节，其他为128个字节
  14            #if (GPS_USART == USART1)
                  xdata volatile u8 Msg_Rx1Buffer[Q_GPS_BUF_LENTH]; //缓存区
                  xdata volatile u8 Msg_Rx2Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx3Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx4Buffer[Q_BUF_LENTH];     //缓存区
                  
                #elif (GPS_USART == USART2)
                  xdata volatile u8 Msg_Rx1Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx2Buffer[Q_GPS_BUF_LENTH]; //缓存区
                  xdata volatile u8 Msg_Rx3Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx4Buffer[Q_BUF_LENTH];     //缓存区
                  
                #elif (GPS_USART == USART3)
  27              xdata volatile u8 Msg_Rx1Buffer[Q_BUF_LENTH];     //缓存区
  28              xdata volatile u8 Msg_Rx2Buffer[Q_BUF_LENTH];     //缓存区
  29              xdata volatile u8 Msg_Rx3Buffer[Q_GPS_BUF_LENTH]; //缓存区
  30              xdata volatile u8 Msg_Rx4Buffer[Q_BUF_LENTH];     //缓存区
  31              
  32            #elif (GPS_USART == USART4)
                  xdata volatile u8 Msg_Rx1Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx2Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx3Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx4Buffer[Q_GPS_BUF_LENTH]; //缓存区
                #else
                  xdata volatile u8 Msg_Rx1Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx2Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx3Buffer[Q_BUF_LENTH];     //缓存区
                  xdata volatile u8 Msg_Rx4Buffer[Q_BUF_LENTH];     //缓存区
                #endif
  43              
  44          #endif
  45          
  46          //========================================================================
  47          // 函数: u8 USART_Configuration(unsigned char UARTx, COMx_InitDefine *COMx)
  48          // 描述: 初始化MCU的UART口.
  49          // 参数: COMx_InitDefine: 结构参数,请参考uart.h里的定义.
  50          // 返回: 无
  51          // 版本: V1.0, 2022-10-17
  52          //========================================================================
  53          void USART_Configuration(unsigned char UARTx, COMx_InitDefine *COMx)
  54          {
C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 2   

  55   1        unsigned char i=0;
  56   1        if(UARTx == USART1)
  57   1        {
  58   2          Msg_RX[UARTx-1].pStart  =   Msg_Rx1Buffer;                                //缓存区开始地址
  59   2          Msg_RX[UARTx-1].pEnd    =   Msg_Rx1Buffer + sizeof(Msg_Rx1Buffer) - 1;    //缓存区结束地址
  60   2          Msg_RX[UARTx-1].pOut    =   Msg_RX[UARTx-1].pStart;                       //数据出口指针
  61   2          Msg_RX[UARTx-1].pIn     =   Msg_RX[UARTx-1].pStart; //数据入口指针  
  62   2          Msg_RX[UARTx-1].overflow_flag = 0;//缓存溢出标志
  63   2          memset(Msg_Rx1Buffer,0,sizeof(Msg_Rx1Buffer));
  64   2          if(COMx->UART_BRT_Use == BRT_Timer1)
  65   2            {
  66   3                PCON &= 0x7F;   //波特率不倍速
  67   3                SCON = 0x50;    //8位数据,可变波特率
  68   3                AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
  69   3                AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
  70   3                TMOD &= 0x0F;   //清除定时器1模式位
  71   3                TMOD |= 0x20;   //设定定时器1为8位自动重装方式
  72   3                TL1 = 256-(MAIN_Fosc / 32) / COMx->UART_BaudRate;   //设定定时初值
  73   3                TH1 = 256-(MAIN_Fosc / 32) / COMx->UART_BaudRate;   //设定定时器重装值
  74   3                ET1 = 0;    //禁止定时器1中断
  75   3                TR1 = 1;    //启动定时器1
  76   3                ES=COMx->UART_Interrupt;//中断允许
  77   3            }
  78   2          else if(COMx->UART_BRT_Use == BRT_Timer2)
  79   2            {
  80   3              #ifdef  STC15W4K48S4  
  81   3                SCON = 0x50;    //8位数据,可变波特率
  82   3                AUXR |= 0x01;   //串口1选择定时器2为波特率发生器
  83   3                AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
  84   3                T2L = (u8)(65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate));
  85   3                T2H = (u8)((65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate))>>8);   //设定定时初值
  86   3                AUXR |= 0x10;   //启动定时器2
  87   3                ES=COMx->UART_Interrupt;//中断允许
  88   3              #endif
  89   3              
  90   3              #ifdef  STC12C5A60S2    
                        PCON &= 0x7F;   //波特率不倍速
                        SCON = 0x50;    //8位数据,可变波特率
                        AUXR |= 0x04;   //独立波特率发生器时钟为Fosc,即1T
                        BRT = 256-(MAIN_Fosc / 32) / COMx->UART_BaudRate;   //设定独立波特率发生器重装值
                        AUXR |= 0x01;   //串口1选择独立波特率发生器为波特率发生器
                        AUXR |= 0x10;   //启动独立波特率发生器
                        ES=COMx->UART_Interrupt;//中断允许
                      #endif
  99   3            }
 100   2      
 101   2        }
 102   1        if(UARTx == USART2)
 103   1        {
 104   2          Msg_RX[UARTx-1].pStart  =   Msg_Rx2Buffer;                                //缓存区开始地址
 105   2          Msg_RX[UARTx-1].pEnd    =   Msg_Rx2Buffer + sizeof(Msg_Rx2Buffer) - 1;  //缓存区结束地址
 106   2          Msg_RX[UARTx-1].pOut    =   Msg_RX[UARTx-1].pStart;                               //数据出口指针
 107   2          Msg_RX[UARTx-1].pIn     =   Msg_RX[UARTx-1].pStart; //数据入口指针  
 108   2          Msg_RX[UARTx-1].overflow_flag = 0;//缓存溢出标志
 109   2          memset(Msg_Rx2Buffer,0,sizeof(Msg_Rx2Buffer));                            //数据入口指针    
 110   2      
 111   2          #ifdef  STC15W4K48S4  
 112   2            S2CON = 0x50;   //8位数据,可变波特率
 113   2            AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
 114   2            T2L = (u8)(65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate));
 115   2            T2H = (u8)((65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate))>>8);   //设定定时初值
 116   2            AUXR |= 0x10;   //启动定时器2 
C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 3   

 117   2            IE2 |=COMx->UART_Interrupt; //开串口2中断  ES2=1=COMx->UART_Interrupt;//中断允许
 118   2          #endif
 119   2          
 120   2          #ifdef  STC12C5A60S2    
                    AUXR &= 0xF7;   //波特率不倍速
                    S2CON = 0x50;   //8位数据,可变波特率
                    AUXR |= 0x04;   //独立波特率发生器时钟为Fosc,即1T
                    BRT = 256-(MAIN_Fosc / 32) / COMx->UART_BaudRate; //设定独立波特率发生器重装值
                    AUXR |= 0x10;   //启动独立波特率发生器
                    IE2 |=COMx->UART_Interrupt; //开串口2中断  ES2=1=COMx->UART_Interrupt;//中断允许
                  #endif
 128   2        }
 129   1        #ifdef  STC15W4K48S4  
 130   1        if(UARTx == USART3)
 131   1        {
 132   2          Msg_RX[UARTx-1].pStart  =   Msg_Rx3Buffer;                                //缓存区开始地址
 133   2          Msg_RX[UARTx-1].pEnd    =   Msg_Rx3Buffer + sizeof(Msg_Rx3Buffer) - 1;  //缓存区结束地址
 134   2          Msg_RX[UARTx-1].pOut    =   Msg_RX[UARTx-1].pStart;                               //数据出口指针
 135   2          Msg_RX[UARTx-1].pIn     =   Msg_RX[UARTx-1].pStart; //数据入口指针  
 136   2          Msg_RX[UARTx-1].overflow_flag = 0;//缓存溢出标志
 137   2          memset(Msg_Rx3Buffer,0,sizeof(Msg_Rx3Buffer));                            //数据入口指针  
 138   2          if(COMx->UART_BRT_Use == BRT_Timer2)
 139   2          {
 140   3            S3CON = 0x10;   //8位数据,可变波特率
 141   3            S3CON &= 0xBF;    //串口3选择定时器2为波特率发生器
 142   3            AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
 143   3            T2L = (u8)(65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate));
 144   3            T2H = (u8)((65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate))>>8);   //设定定时初值
 145   3            AUXR |= 0x10;   //启动定时器2
 146   3            IE2 |= (COMx->UART_Interrupt << 3);//中断允许
 147   3          }
 148   2          else if(COMx->UART_BRT_Use == BRT_Timer3)
 149   2          {
 150   3            S3CON = 0x10;   //8位数据,可变波特率
 151   3            S3CON |= 0x40;    //串口3选择定时器3为波特率发生器
 152   3            T4T3M |= 0x02;    //定时器3时钟为Fosc,即1T
 153   3            T3L = (u8)(65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate));
 154   3            T3H = (u8)((65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate))>>8);   //设定定时初值
 155   3            T4T3M |= 0x08;    //启动定时器3 
 156   3            IE2 |= (COMx->UART_Interrupt << 3);//中断允许     
 157   3          }
 158   2        
 159   2        }
 160   1        if(UARTx == USART4)
 161   1        {
 162   2          Msg_RX[UARTx-1].pStart  =   Msg_Rx4Buffer;                                //缓存区开始地址
 163   2          Msg_RX[UARTx-1].pEnd    =   Msg_Rx4Buffer + sizeof(Msg_Rx4Buffer) - 1;    //缓存区结束地址
 164   2          Msg_RX[UARTx-1].pOut    =   Msg_RX[UARTx-1].pStart;                       //数据出口指针
 165   2          Msg_RX[UARTx-1].pIn     =   Msg_RX[UARTx-1].pStart;                       //数据入口指针  
 166   2          Msg_RX[UARTx-1].overflow_flag = 0;                                        //缓存溢出标志
 167   2          memset(Msg_Rx4Buffer,0,sizeof(Msg_Rx4Buffer));                            //数据入口指针  
 168   2          if(COMx->UART_BRT_Use == BRT_Timer2)
 169   2          {
 170   3            S4CON = 0x10;   //8位数据,可变波特率
 171   3            S4CON &= 0xBF;    //串口4选择定时器2为波特率发生器
 172   3            AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
 173   3            T2L = (u8)(65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate));
 174   3            T2H = (u8)((65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate))>>8);   //设定定时初值
 175   3            AUXR |= 0x10;   //启动定时器2
 176   3            IE2 |= (COMx->UART_Interrupt << 4);//中断允许 
 177   3          }
 178   2          else if(COMx->UART_BRT_Use == BRT_Timer4)
C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 4   

 179   2          {
 180   3            S4CON = 0x10;   //8位数据,可变波特率
 181   3            S4CON |= 0x40;    //串口4选择定时器4为波特率发生器
 182   3            T4T3M |= 0x20;    //定时器4时钟为Fosc,即1T
 183   3            T4L = (u8)(65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate));
 184   3            T4H = (u8)((65535UL - ((MAIN_Fosc / 4) / COMx->UART_BaudRate))>>8);   //设定定时初值  
 185   3            T4T3M |= 0x80;    //启动定时器4 
 186   3            IE2 |= (COMx->UART_Interrupt << 4);//中断允许   
 187   3          } 
 188   2        }
 189   1        #endif
 190   1        
 191   1      }
 192          /*******************************************************************************/
 193          void int_4(void) interrupt 4 //串口1中断
 194          {
 195   1        if(RI==1)
 196   1        { 
 197   2          RI=0;
 198   2          if((Msg_RX[0].pIn >= Msg_RX[0].pOut) && (Msg_RX[0].overflow_flag == 1))
 199   2          {
 200   3      
 201   3            Msg_RX[0].pIn = Msg_RX[0].pStart;
 202   3            Msg_RX[0].pOut = Msg_RX[0].pStart;
 203   3            Msg_RX[0].overflow_flag = 0;  
 204   3          }
 205   2          if(Msg_RX[0].pIn == Msg_RX[0].pEnd)   //处理边界
 206   2          {
 207   3            *Msg_RX[0].pIn  = SBUF;           //数据入队  
 208   3            Msg_RX[0].pIn   = Msg_RX[0].pStart; //循环到初始位置
 209   3            Msg_RX[0].overflow_flag = 1;      //已经经过边界
 210   3          }
 211   2          else 
 212   2          {
 213   3            *Msg_RX[0].pIn++ = SBUF;
 214   3          }
 215   2      
 216   2        }
 217   1      }
 218          /*****************************************************************************/
 219          void int_8(void) interrupt 8 //串口2中断
 220          {
 221   1        if(S2CON&0x01)  //S2RI=1
 222   1        {
 223   2          S2CON&=0xfe; 
 224   2          if((Msg_RX[1].pIn == Msg_RX[1].pOut) && (Msg_RX[1].overflow_flag == 1))//队列溢出
 225   2          {
 226   3            Msg_RX[1].pIn = Msg_RX[1].pStart;
 227   3            Msg_RX[1].pOut = Msg_RX[1].pStart;
 228   3            Msg_RX[1].overflow_flag = 0;  
 229   3          }
 230   2          if(Msg_RX[1].pIn == Msg_RX[1].pEnd)   //处理边界
 231   2          {
 232   3            *Msg_RX[1].pIn  = S2BUF;            //数据入队  
 233   3            Msg_RX[1].pIn   = Msg_RX[1].pStart; //循环到初始位置
 234   3            Msg_RX[1].overflow_flag = 1;      //已经经过边界
 235   3          }
 236   2          else 
 237   2          {
 238   3            *Msg_RX[1].pIn++ = S2BUF; 
 239   3          }
 240   2        }
C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 5   

 241   1        
 242   1      }
 243          
 244          #ifdef  STC15W4K48S4  
 245          //========================================================================
 246          //描述: 串口3中断
 247          //========================================================================
 248          void UART3_int (void) interrupt UART3_VECTOR //串口中断3
 249          {
 250   1        if(RI3) 
 251   1        {
 252   2          CLR_RI3(); 
 253   2          if((Msg_RX[2].pIn == Msg_RX[2].pOut) && (Msg_RX[2].overflow_flag == 1))//队列溢出
 254   2          {
 255   3            Msg_RX[2].pIn = Msg_RX[2].pStart;
 256   3            Msg_RX[2].pOut = Msg_RX[2].pStart;
 257   3            Msg_RX[2].overflow_flag = 0;  
 258   3          }
 259   2          if(Msg_RX[2].pIn == Msg_RX[2].pEnd)   //处理边界
 260   2          {
 261   3            *Msg_RX[2].pIn  = S3BUF;            //数据入队  
 262   3            Msg_RX[2].pIn   = Msg_RX[2].pStart; //循环到初始位置
 263   3            Msg_RX[2].overflow_flag = 1;      //已经经过边界
 264   3          }
 265   2          else 
 266   2          {
 267   3            *Msg_RX[2].pIn++ = S3BUF; 
 268   3          }
 269   2        }
 270   1        
 271   1      }
 272          #endif
 273          #ifdef  STC15W4K48S4  
 274          //========================================================================
 275          //描述: 串口4中断
 276          //========================================================================
 277          void UART4_int (void) interrupt UART4_VECTOR //串口中断4
 278          {
 279   1        if(RI4) 
 280   1        {   
 281   2          CLR_RI4();
 282   2          if((Msg_RX[3].pIn == Msg_RX[3].pOut) && (Msg_RX[3].overflow_flag == 1))//队列溢出
 283   2          {
 284   3            Msg_RX[3].pIn = Msg_RX[3].pStart;
 285   3            Msg_RX[3].pOut = Msg_RX[3].pStart;
 286   3            Msg_RX[3].overflow_flag = 0;  
 287   3          }
 288   2          if(Msg_RX[3].pIn == Msg_RX[3].pEnd)   //处理边界
 289   2          {
 290   3            *Msg_RX[3].pIn  = S4BUF;            //数据入队  
 291   3            Msg_RX[3].pIn   = Msg_RX[3].pStart; //循环到初始位置
 292   3            Msg_RX[3].overflow_flag = 1;      //已经经过边界
 293   3          }
 294   2          else 
 295   2          {
 296   3            *Msg_RX[3].pIn++ = S4BUF; 
 297   3          }
 298   2        }
 299   1        
 300   1      }
 301          #endif
 302          //========================================================================
C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 6   

 303          // 函数: u8 USART_ReadRxBuffer(u8 UARTx，u8 *pbuffer,u16 *lenth)
 304          // 描述: 读取串口的缓存数据到指定的内存块
 305          // 参数: u8 UARTx需要读的端口号，u8 *pbuffer内存块的地址，u16 Buflenth为缓存区的大小.
 306          // 返回: 返回读取数据的长度
 307          // 版本: V1.0, 2022-10-17
 308          //========================================================================
 309          u16 USART_ReadRxBuffer(u8 UARTx, u8 *pbuffer, u16 Buflenth)
 310          {
 311   1        u8 *pIn   =   Msg_RX[UARTx-1].pIn;
 312   1        u8 *pOut  =   Msg_RX[UARTx-1].pOut;
 313   1        xdata u16 lenth = 0;
 314   1        xdata u8 *ptemp = pbuffer;
 315   1      
 316   1        while(pOut != pIn)          //1次读取所有的缓存
 317   1        {
 318   2          lenth++;  //记录读出的数据长度  
 319   2          if (lenth < Buflenth)           //判断数组是否越界
 320   2          {    
 321   3              if(pOut == Msg_RX[UARTx-1].pEnd)  //处理边界
 322   3              {
 323   4                  *pbuffer++ = *pOut;   //数据出队        
 324   4                    pOut     = Msg_RX[UARTx-1].pStart;//循环到初始位置
 325   4                  Msg_RX[UARTx-1].overflow_flag = 0;    //溢出标志清0
 326   4              }
 327   3              else 
 328   3              {       
 329   4                  *pbuffer++ = *pOut++; //数据出队 
 330   4              }
 331   3            #ifdef DEBUG
                      printf("RxBuffer[%bd] = %b02x",(u8)(lenth-1),*(pbuffer-1)); 
                      printf("\r\n");
                    #endif
 335   3          }
 336   2          else          //缓存数组越界
 337   2          {
 338   3            #ifdef DEBUG
                    printf("USART_ReadRxBuffer:Index overflow!!!\r\n"); 
                    #endif    
 341   3            break;//退出，不再拷贝
 342   3          }
 343   2        }
 344   1        Msg_RX[UARTx-1].pOut = pIn; //将数据出口位置移到入口位置，准备进行下一轮读取
 345   1        return lenth;
 346   1          
 347   1      }
 348          //========================================================================
 349          // 函数: void USART_ClearMsgQueueRxBuffer(u8 UARTx)
 350          // 描述: 清理串口缓存数据
 351          // 参数: u8 UARTx需要清理的串口号
 352          // 返回: 
 353          // 版本: V1.0, 2022-10-17
 354          //========================================================================
 355          void USART_ClearMsgQueueRxBuffer(u8 UARTx)
 356          {
 357   1            u16 Bufferlenth = 0;
 358   1        
 359   1            switch(UARTx)
 360   1            {
 361   2              case USART1:
 362   2                          ES = 0;//关闭中断
 363   2                          break;
 364   2              case USART2:
C51 COMPILER V9.56.0.0   USART                                                             11/15/2022 13:44:43 PAGE 7   

 365   2                          IE2 &= ~(1<< 0);//关闭中断
 366   2                          break;
 367   2      #ifdef  STC15W4K48S4  
 368   2              case USART3:
 369   2                          IE2 &= ~(1<< 3);//关闭中断
 370   2                          break;
 371   2              case USART4:
 372   2                          IE2 &= ~(1<< 4);//关闭中断
 373   2                          break;
 374   2      #endif
 375   2              default:
 376   2                          return;
 377   2            }
 378   1        
 379   1            Bufferlenth = Msg_RX[UARTx-1].pEnd - Msg_RX[UARTx-1].pStart +1;//计算缓存区的长度
 380   1        
 381   1            memset(Msg_RX[UARTx-1].pStart,0,Bufferlenth);//清理缓存
 382   1        
 383   1            Msg_RX[UARTx-1].pIn = Msg_RX[UARTx-1].pStart;//复位数据入口指针
 384   1        
 385   1            Msg_RX[UARTx-1].pOut = Msg_RX[UARTx-1].pStart;//复位数据出口指针
 386   1        
 387   1            Msg_RX[UARTx-1].overflow_flag = 0;//溢出标志清零
 388   1        
 389   1            switch(UARTx)
 390   1            {
 391   2              case USART1:
 392   2                          ES = 1;//开启中断
 393   2                          break;
 394   2              case USART2:
 395   2                          IE2 |=(1<< 0);//开启中断
 396   2                          break;
 397   2      #ifdef  STC15W4K48S4
 398   2              case USART3:
 399   2                          IE2 |= (1<< 3);//开启中断
 400   2                          break;
 401   2              case USART4:
 402   2                          IE2 |= (1<< 4);//开启中断
 403   2                          break;
 404   2              default:
 405   2                          return;
 406   2      #endif
 407   2            }
 408   1          
 409   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3062    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    936       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
